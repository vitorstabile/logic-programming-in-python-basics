<h1 align="center"> Python </h1>

# Content

1. [Chapter 1: Rapid Introduction to Procedural Programming](#chapter1)
    - [Chapter 1 - Part 1: Creating and Running Python Programs](#chapter1part1)
    - [Chapter 1 - Part 2: Data Types in Python](#chapter1part2)
    - [Chapter 1 - Part 3: Object References in Python](#chapter1part3)
    - [Chapter 1 - Part 4: Collection Data Types in Python](#chapter1part4)
    - [Chapter 1 - Part 5: Logical Operations in Python](#chapter1part5)
      - [Chapter 1 - Part 5.1: The Identity Operator](#chapter1part5.1)
      - [Chapter 1 - Part 5.2: Comparison Operators](#chapter1part5.2)
      - [Chapter 1 - Part 5.3: The Membership Operator](#chapter1part5.3)
      - [Chapter 1 - Part 5.4: Logical Operators](#chapter1part5.4)
    - [Chapter 1 - Part 6: Control Flow Statements in Python](#chapter1part6)
      - [Chapter 1 - Part 6.1: The if Statement](#chapter1part6.1)
      - [Chapter 1 - Part 6.2: The while Statement](#chapter1part6.2)
      - [Chapter 1 - Part 6.3: The for …in Statement](#chapter1part6.3)
      - [Chapter 1 - Part 6.4: Basic Exception Handling](#chapter1part6.4)
    - [Chapter 1 - Part 7: Arithmetic Operators in Python](#chapter1part7)
    - [Chapter 1 - Part 8: Input/Output in Python](#chapter1part8)
    - [Chapter 1 - Part 9: Creating and Calling Functions in Python](#chapter1part9)
2. [Chapter 2: Data Types](#chapter2)
    - [Chapter 2 - Part 1: Identifiers and Keywords](#chapter2part1)
    - [Chapter 2 - Part 2: Integral Types](#chapter2part2)
      - [Chapter 2 - Part 2.1: Integers](#chapter2part2.1)
      - [Chapter 2 - Part 2.2: Booleans](#chapter2part2.2)
      - [Chapter 2 - Part 2.3: Integer Bitwise Operators](#chapter2part2.3)
    - [Chapter 2 - Part 3: Floating-Point Types](#chapter2part3)
      - [Chapter 2 - Part 3.1: Floating-Point Numbers](#chapter2part3.1)
      - [Chapter 2 - Part 3.2: Complex Numbers](#chapter2part3.2)
      - [Chapter 2 - Part 3.3: Decimal Numbers](#chapter2part3.3)
    - [Chapter 2 - Part 4: Strings](#chapter2part4)
      - [Chapter 2 - Part 4.1: Comparing Strings](#chapter2part4.1)
      - [Chapter 2 - Part 4.2: Slicing and Striding Strings](#chapter2part4.2)
      - [Chapter 2 - Part 4.3: String Operators and Methods](#chapter2part4.3)
      - [Chapter 2 - Part 4.4: String Formatting with the str.format() Method](#chapter2part4.4)
      - [Chapter 2 - Part 4.5: Field Names](#chapter2part4.5)
3. [Chapter 3: Collection Data Types](#chapter3)
    - [Chapter 3 - Part 1: Sequence Types](#chapter3part1)
      - [Chapter 3 - Part 1.1: Tuples](#chapter3part1.1)
      - [Chapter 3 - Part 1.2: Named Tuples](#chapter3part1.2)
      - [Chapter 3 - Part 1.3: Lists](#chapter3part1.3)
      - [Chapter 3 - Part 1.4: List Comprehensions](#chapter3part1.4)
    - [Chapter 3 - Part 2: Set Types](#chapter3part2)
      - [Chapter 3 - Part 2.1: Sets](#chapter3part2.1)
      - [Chapter 3 - Part 2.2: Set Comprehensions](#chapter3part2.2)
      - [Chapter 3 - Part 2.3: Frozen Sets](#chapter3part2.3) 
    - [Chapter 3 - Part 3: Mapping Types](#chapter3part3)
      - [Chapter 3 - Part 3.1: Dictionaries](#chapter3part3.1)
      - [Chapter 3 - Part 3.2: Dictionary Comprehensions](#chapter3part3.2)
      - [Chapter 3 - Part 3.3: Default Dictionaries](#chapter3part3.3)
      - [Chapter 3 - Part 3.4: Ordered Dictionaries](#chapter3part3.4)
    - [Chapter 3 - Part 4: Iterating and Copying Collections](#chapter3part4)
      - [Chapter 3 - Part 4.1: Iterators and Iterable Operations and Functions](#chapter3part4.1)
      - [Chapter 3 - Part 4.2: Copying Collections](#chapter3part4.2)
4. [Chapter 4: Control Structures and Functions](#chapter4)
    - [Chapter 4 - Part 1: Control Structures](#chapter4part1)
      - [Chapter 4 - Part 1.1: Conditional Branching](#chapter4part1.1)
      - [Chapter 4 - Part 1.2: Looping](#chapter4part1.2)
      - [Chapter 4 - Part 1.3: While Loops](#chapter4part1.3)
      - [Chapter 4 - Part 1.4: For Loops](#chapter4part1.4)
    - [Chapter 4 - Part 2: Exception Handling](#chapter4part2)
      - [Chapter 4 - Part 2.1: Catching and Raising Exceptions](#chapter4part2.1)
      - [Chapter 4 - Part 2.2: Raising Exceptions](#chapter4part2.2)
      - [Chapter 4 - Part 2.3: Custom Exceptions](#chapter4part2.3)
    - [Chapter 4 - Part 3: Custom Functions](#chapter4part3)
      - [Chapter 4 - Part 3.1: Names and Docstrings](#chapter4part3.1)
      - [Chapter 4 - Part 3.2: Argument and Parameter Unpacking](#chapter4part3.2)
      - [Chapter 4 - Part 3.3: Accessing Variables in the Global Scope](#chapter4part3.3)
      - [Chapter 4 - Part 3.4: Lambda Functions](#chapter4part3.4)
      - [Chapter 4 - Part 3.5: Assertions](#chapter4part3.5)
5. [Chapter 5: Modules](#chapter5)
    - [Chapter 5 - Part 1: Modules and Packages](#chapter5part1)
      - [Chapter 5 - Part 1.1: Packages](#chapter5part1.1)
      - [Chapter 5 - Part 1.2: Custom Modules](#chapter5part1.2)
      - [Chapter 5 - Part 1.3: The TextUtil Module](#chapter5part1.3)
      - [Chapter 5 - Part 1.4: The CharGrid Module](#chapter5part1.4)
    - [Chapter 5 - Part 2: Overview of Python’s Standard Library](#chapter5part2)
      - [Chapter 5 - Part 2.1: String Handling](#chapter5part2.1)
      - [Chapter 5 - Part 2.2: Command-Line Programming](#chapter5part2.2)
      - [Chapter 5 - Part 2.3: Mathematics and Numbers](#chapter5part2.3)
      - [Chapter 5 - Part 2.4: Times and Dates](#chapter5part2.4)
      - [Chapter 5 - Part 2.5: Algorithms and Collection Data Types](#chapter5part2.5)
      - [Chapter 5 - Part 2.6: File Formats, Encodings, and Data Persistence](#chapter5part2.6)
      - [Chapter 5 - Part 2.7: File, Directory, and Process Handling](#chapter5part2.7)
      - [Chapter 5 - Part 2.8: Networking and Internet Programming](#chapter5part2.8)
      - [Chapter 5 - Part 2.9: XML](#chapter5part2.9)
      - [Chapter 5 - Part 2.10: Other Modules](#chapter5part2.10)  
6. [Chapter 6: Object-Oriented Programming](#chapter6)
    - [Chapter 6 - Part 1: The Object-Oriented Approach](#chapter6part1)
      - [Chapter 6 - Part 1.1: Object-Oriented Concepts and Terminology](#chapter6part1.1)
    - [Chapter 6 - Part 2: Custom Classes](#chapter6part2)
      - [Chapter 6 - Part 2.1: Attributes and Methods](#chapter6part2.1)
      - [Chapter 6 - Part 2.2: Inheritance and Polymorphism](#chapter6part2.2)
      - [Chapter 6 - Part 2.3: Using Properties to Control Attribute Access](#chapter6part2.3)
      - [Chapter 6 - Part 2.4: Creating Complete Fully Integrated Data Types](#chapter6part2.4)
      - [Chapter 6 - Part 2.5: Creating Data Types from Scratch](#chapter6part2.5)
      - [Chapter 6 - Part 2.6: Creating Data Types from Other Data Types](#chapter6part2.6)
    - [Chapter 6 - Part 3: Custom Collection Classes](#chapter6part3)
      - [Chapter 6 - Part 3.1: Creating Classes That Aggregate Collections](#chapter6part3.1)
      - [Chapter 6 - Part 3.2: Creating Collection Classes Using Aggregation](#chapter6part3.2)
      - [Chapter 6 - Part 3.3: Creating Collection Classes Using Inheritance](#chapter6part3.3)
7. [Chapter 7: File Handling](#chapter7)
    - [Chapter 7 - Part 1: Writing and Reading Binary Data](#chapter7part1)
      - [Chapter 7 - Part 1.1: Pickles with Optional Compression](#chapter7part1.1)
      - [Chapter 7 - Part 1.2: Raw Binary Data with Optional Compression](#chapter7part1.2)
    - [Chapter 7 - Part 2: Writing and Parsing Text Files](#chapter7part2)
      - [Chapter 7 - Part 2.1: Writing Text](#chapter7part2.1)
      - [Chapter 7 - Part 2.2: Parsing Text](#chapter7part2.2)
      - [Chapter 7 - Part 2.3: Parsing Text Using Regular Expressions](#chapter7part2.3)
    - [Chapter 7 - Part 3: Writing and Parsing XML Files](#chapter7part3)
      - [Chapter 7 - Part 3.1: Element Trees](#chapter7part3.1)
      - [Chapter 7 - Part 3.2: DOM (Document Object Model)](#chapter7part3.2)
      - [Chapter 7 - Part 3.3: Manually Writing XML](#chapter7part3.3)
      - [Chapter 7 - Part 3.4: Parsing XML with SAX (Simple API for XML)](#chapter7part3.4)
    - [Chapter 7 - Part 4: Random Access Binary Files](#chapter7part4)
      - [Chapter 7 - Part 4.1: A Generic BinaryRecordFile Class](#chapter7part4.1)
8. [Appendix A: Useful Python Code Snippet](#appendixa)
    - [Appendix A - Part 1: Create a Log file](#appendixapart1)
    - [Appendix A - Part 2: List all files of a directory based in a extension](#appendixapart2)
    - [Appendix A - Part 3: List all files of a directory based in a regex](#appendixapart3)
    - [Appendix A - Part 4: Move file to a directory](#appendixapart4)
    - [Appendix A - Part 5: Read a Config Json File](#appendixapart5)
    - [Appendix A - Part 6: Read and Parse a CSV file with Pandas based in a Config Json File](#appendixapart6)
    - [Appendix A - Part 7: Read a CSV file with Pandas and iteract over the rows with custom functions using apply()](#appendixapart7)
    
## <a name="chapter1"></a>Chapter 1: Rapid Introduction to Procedural Programming

#### <a name="chapter1part1"></a>Chapter 1 - Part 1: Creating and Running Python Programs

Python code can be written using any plain text editor that can load and save text using either the ASCII or the UTF-8 Unicode character encoding.

By default, Python files are assumed to use the UTF-8 character encoding, a superset of ASCII that can represent pretty well every character in every language. 

Python files normally have an extension of .py, although on some Unix-like systems (e.g., Linux and Mac OS X) some Python applications have no extension, and Python GUI (Graphical User Interface) programs usually have an extension of .pyw, particularly onWindows and Mac OSX.

Create a file called hello.py in a plain text editor with the following contents:

```py
#!/usr/bin/env python3

print("Hello", "World!")
```

The first line is a comment. In Python,commentsbegin with a # and continue to the end of the line.

The second line is blank—outside quoted strings, Python ignores blank lines, but they are often useful to humans to break up large blocks of code to make them easier to read.

The third line is Python code. Here, the print() function is called with two arguments, each of type str (string; i.e., a sequence of characters).

Each statement encountered in a .py file is executed in turn, starting with the first one and progressing line by line. This is different from some other languages, for example, C++ and Java, which have a particular function or method with a special name where they start from.

We will assume that Windows users keep their Python code in the C:\py3eg directory and that Unix (i.e., Unix, Linux, and Mac OS X) users keep their code in the $HOME/py3eg directory. Save hello.py into the py3eg directory and close the text editor.

Now that we have a program, we can run it. Python programs are executed by the Python interpreter, and normally this is done inside a console window.

On Windows the console is called "Command Prompt"

On Mac OS X the console is provided by the Terminal.app program (located in Applications/Utilities by default), available using Finder, and on other Unixes,we can use an xterm or the console provided by the windowing environment, for example, konsole or gnome-terminal.

Start up a console, and on Windows enter the following commands

```
C:\>cd c:\py3eg
C:\py3eg\>c:\python31\python.exe hello.py
```

Unix users enter this instead (assuming that Python 3 is in the PATH):*

```
$ cd $HOME/py3eg
$ python3 hello.py
```

In both cases the output should be the same:

```
Hello World!
```

Although the program has just one executable statement, by running it we can infer some information about the print() function. For one thing, print() is a built-in part of the Python language—we didn’t need to “import” or “include” it from a library to make use of it. Also, it separates each item it prints with a single space, and prints a newline after the last item is printed.

#### <a name="chapter1part2"></a>Chapter 1 - Part 2: Data Types in Python

In programming, data type is an important concept.

Variables can store data of different types, and different types can do different things.

Python has the following data types built-in by default, in these categories:

- Text Type: ```str```
- Numeric Types: ```int```, ```float```, ```complex```
- Sequence Types: ```list```, ```tuple```, ```range```
- Mapping Type: ```dict```
- Set Types: ```set```, ```frozenset```
- Boolean Type: ```bool```
- Binary Types: ```bytes```, ```bytearray```, ```memoryview```
- None Type: ```NoneType```

Python represents integers (positive and negative whole numbers) using the int type, and it represents strings (sequences of Unicode characters) using the str type.

**Integers Examples**

```
-973
210624583337114373395836055367340864637790190801098222508621955072
0
```

Incidentally, the second number shown is the size of Python’s integers is limited only by machine memory, not by a fixed number of bytes.

**Strings Examples**

```
"Infinitely Demanding"
'Simon Critchley'
'positively αβγ ÷©'
''
```

Strings can be delimited by double or single quotes, as long as the same kind are used at both ends, and since Python uses Unicode, strings are not limited to ASCII characters, as the penultimate string shows. An empty string is simply one with nothing between the delimiters.

Python uses square brackets ([]) to access an item from a sequence such as
a string.

```py
print("Hard Times"[5])
```

```
T
```

```py
print("giraffe"[0])
```

```
g
```

In Python, both str and the basic numeric types such as int are immutable, that is, once set, their value cannot be changed.

To convert a data item from one type to another we can use the syntax datatype(item).

```py
int("45")
```

```py
str(912)
```

The int() conversion is tolerant of leading and trailing whitespace, so int(" 45 ") would have worked just as well. The str() conversion can be
applied to almost any data item. We can easily make our own custom data types support str() conversion, and also int() or other conversions if they make sense.
If a conversion fails, an exception is raised

#### <a name="chapter1part3"></a>Chapter 1 - Part 3: Object References in Python

Python doesn’t have variables as such, but instead has object references.

When it comes to immutable objects like ints and strs, there is no discernable difference between a variable and an object reference.

As for mutable objects, there is a difference, but it rarely matters in practice.

Let’s look at a few tiny examples, and then discuss some of the details.

```py
x = "blue"
y = "green"
z = x
```

The syntax is simply objectReference = value.

When Python executes the first statement it creates a str object with the text “blue”, and creates an object reference called x that refers to the str object.

For all practical purposes we can say that “variable x has been assigned the ‘blue’ string”. The second statement is similar. The third statement creates a new object reference called z and sets it to refer to the same object that the x object reference refers to (in this case the str containing the text “blue”).

The = operator is not the same as the variable assignment operator in some other languages. The = operator binds an object reference to an object in memory. If the object reference already exists, it is simply re-bound to refer to the object on the right of the = operator if the object reference does not exist it is created by the = operator.

```py
print(x, y, z) # prints: blue green blue
z = y
print(x, y, z) # prints: blue green green
x = z
print(x, y, z) # prints: green green green
```

After the fourth statement (x = z), all three object references are referring to the same str. Since there are no more object references to the “blue” string, Python is free to garbage-collect it.

<br>

<div align="center"><img src="img/objectreference-w610-h640.png" width=610 height=640><br><sub>Object references and objects (The circles represent object references.The rectangles represent objects in memory.) - (<a href='https://github.com/vitorstabile'>Work by Vitor Garcia</a>) </sub></div>

<br>

The names used for object references (called identifiers) have a few restrictions. In particular, they may not be the same as any of Python’s keywords, and must start with a letter or an underscore and be followed by zero or more nonwhitespace letter, underscore, or digit characters. There is no length limit, and the letters and digits are those defined by Unicode, that is, they include, but are not limited to, ASCII’s letters and digits (“a”, “b”, …, “z”, “A”, “B”,…, “Z”, “0”, “1”, …, “9”). Python identifiers are case-sensitive, so for example, LIMIT, Limit, and limit are three different identifiers.

Python uses dynamic typing, which means that an object reference can be rebound to refer to a different object (which may be of a different data type) at any time. Languages that use strong typing (such as C++ and Java) allow only those operations that are defined for the data types involved to be performed. Python also applies this constraint, but it isn’t called strong typing in Python’s case because the valid operations can change—for example, if an object reference is re-bound to an object of a different data type.

```py
route = 866
print(route, type(route)) # prints: 866 <class 'int'>
```

```py
route = "North"
print(route, type(route)) # prints: North <class 'str'>
```

Here we create a new object reference called route and set it to refer to a new int of value 866. At this point we could use / with route since division is a valid operation for integers. Then we reuse the route object reference to refer to a new str of value “North”, and the int object is scheduled for garbage collection since now no object reference refers to it. At this point using / with route would cause a TypeError to be raised since / is not a valid operation for a string.

The type() function returns the data type (also known as the "class”) of the data item it is given—this function can be very useful for testing and debugging.

#### <a name="chapter1part4"></a>Chapter 1 - Part 4: Collection Data Types in Python

There are four collection data types in the Python programming language:

- List: is a collection which is ordered and changeable. Allows duplicate members.
- Tuple: is a collection which is ordered and unchangeable. Allows duplicate members.
- Set: is a collection which is unordered, unchangeable*, and unindexed. No duplicate members.
- Dictionary: is a collection which is ordered** and changeable. No duplicate members.

But here we will introduce just two: tuple and list. Python tuples and lists can be used to hold any number of data items of any data types. Tuples are immutable, so once they are created we cannot change them. Lists are mutable, so we can easily insert items and remove items whenever we want.

Tuples are created using commas (,), as these examples show

```py
print("Denmark", "Finland", "Norway", "Sweden") # prints: ('Denmark', 'Finland', 'Norway', 'Sweden')
```

```py
print("one",) # prints: ('one',)
```

An empty tuple is created by using empty parentheses, (). The comma is also used to separate arguments in function calls, so if we want to pass a tuple literal as an argument we must enclose it in parentheses to avoid confusion.

Here are some example lists:

```py
print([1, 4, 9, 16, 25, 36, 49])
print(['alpha', 'bravo', 'charlie', 'delta', 'echo'])
print(['zebra', 49, -879, 'aardvark', 200])
print([])
```

One way to create a list is to use square brackets ([]). The fourth list shown is an empty list.

When lists and tuples are created (and when items are inserted in the case of lists), they take copies of the object references they are given. In the case of literal items such as integers or strings, an object of the appropriate
data type is created in memory and suitably initialized, and then an object reference referring to the object is created, and it is this object reference that is put in the list or tuple.

Tuples, lists, and strings are “sized”, that is, they are data types that have a notion of size, and data items of any such data type can be meaningfully passed to the len() function. (An exception is raised if a nonsized data item is passed to len().)

```py
len(("one",)) # 1
```

```py
len([3, 5, 1, 2, "pause", 5]) # 6
```

```py
len("automatically") # 13
```

All Python data items are objects (also called instances) of a particular data type (also called a class)

Essentially, a method is simply a function that is called for a particular object. For example, the list type has an append() method, so we can append an object to a list like this:

```py
x = ["zebra", 49, -879, "aardvark", 200]
x.append("more")
print(x) # ['zebra', 49, -879, 'aardvark', 200, 'more']
``` 

The append() method mutates, that is, changes, the original list. This is possible because lists are mutable.

The list type has many other methods, including insert() which is used to insert an item at a given index position,and remove() which removes an item at a given index position. As noted earlier, Python indexes are always 0-based.

```py
x = ['zebra', 49, -879, 'aardvark', 200, 'more', 'extra']
print(x[0]) # print: zebra
print(x[4]) # print: 200
```

Tuples are also sequences, so if x had been a tuple we could retrieve items using square brackets in exactly the same way aswe have done for the x list. But since lists are mutable (unlike strings and tuples which are immutable),we can also use the square brackets operator to set list elements.

```py
x = ['zebra', 49, -879, 'aardvark', 200, 'more', 'extra']
x[1] = "forty nine"
print(x) # print: ['zebra', 'forty nine', -879, 'aardvark', 200, 'more', 'extra']
```

#### <a name="chapter1part5"></a>Chapter 1 - Part 5: Logical Operations in Python

###### <a name="chapter1part5.1"></a>Chapter 1 - Part 5.1: The Identity Operator

The is operator is a binary operator that returns True if its left-hand object reference is referring to the same object as its right-hand object reference.

```py
a = ["Retention", 3, None]
b = ["Retention", 3, None]
print(a is b) # print: False
b = a
print(a is b) # print: True
```

One benefit of identity comparisons is that they are very fast. This is because the objects referred to do not have to be examined themselves. The is operator needs to compare only the memory addresses of the objects—the same address means the same object.

The most common use case for is is to compare a data item with the built-in null object, None, which is often used as a place-marking value to signify “unknown” or “nonexistent”:

```py
a = "Something"
b = None
print(a is not None, b is None) # print: (True, True)
```

To invert the identity test we use ```is not```.

###### <a name="chapter1part5.2"></a>Chapter 1 - Part 5.2: Comparison Operators

- ```<``` less than
- ```<=``` less than or equal to,
- ```==``` equal to
- ```!=``` not equal
- ```>=``` greater than or equal to
- ```>``` greater than

```py
a = 2
b = 6
print(a == b) # print: False
print(a < b) # print: True
print(a <= b, a != b, a >= b, a > b) # print: (True, True, False, False)
```

```py
a = ["many paths"]
b = ["many paths"]
print(a is b) # print: False
print(a == b) # print: True
```

The moral of this is to use == and != when comparing values, and to use ```is``` and ```is not``` only when comparing with ```None``` or when we really do want to see if two object references, rather than their values, are the same.

###### <a name="chapter1part5.3"></a>Chapter 1 - Part 5.3: The Membership Operator

For data types that are sequences or collections such as strings, lists, and tuples, we can test for membership using the ```in``` operator,and for nonmembership using the ```not in``` operator.

```py
p = (4, "frog", 9, -33, 9, 2)
print(2 in p) # print: True
print("dog" not in p) # print: True
```

```py
phrase = "Wild Swans by Jung Chang"
print("J" in phrase) # print: True
print("han" in phrase) # print: True
```

###### <a name="chapter1part5.4"></a>Chapter 1 - Part 5.4: Logical Operators

Python provides three logical operators: ```and```, ```or```, and ```not```. Both ```and``` and ```or``` use short-circuit logic and return the operand that determined the result—they do not return a Boolean (unless they actually have Boolean operands).

```py
five = 5
two = 2
zero = 0
print(five and two) # print: 2
print(two and five) # print: 5 
print(five and zero) # print: 0
```

If the expression occurs in a Boolean context, the result is evaluated as a Boolean, so the preceding expressions would come out as ```True```, ```True```, and ```False``` in, say, an ```if``` statement.

```py
nought = 0
five = 5
two = 2
zero = 0
print(five or two) # print: 5
print(two or five) # print: 2
print(zero or five) # print: 5
print(zero or nought) # print: 0
```

The ```or``` operator is similar; here the results in a Boolean context would be ```True```, ```True```, ```True```, and ```False```.

The ```not``` unary operator evaluates its argument in a Boolean context and always returns a Boolean result, so to continue the earlier example, ```not (zero or nought)``` would produce ```True```, and ```not two``` would produce ```False```.

#### <a name="chapter1part6"></a>Chapter 1 - Part 6: Control Flow Statements in Python

###### <a name="chapter1part6.1"></a>Chapter 1 - Part 6.1: The if Statement

The general syntax for Python’s if statement is this:

```
if boolean_expression1:
    suite1
elif boolean_expression2:
    suite2
...
elif boolean_expressionN:
    suiteN
else:
    else_suite
```

There can be zero or more ```elif``` clauses, and the final ```else``` clause is optional. If we want to account for a particular case, but want to do nothing if it occurs,we can use ```pass``` as that branch’s suite.

Unlike most other programming languages, Python uses indentation to signify its block structure. The Python style guidelines recommend four spaces per level of indentation, and only spaces (no tabs).

```py
if x:
    print("x is nonzero")
```

```py
if lines < 1000:
    print("small")
elif lines < 10000:
    print("medium")
else:
    print("large")
```

###### <a name="chapter1part6.2"></a>Chapter 1 - Part 6.2: The while Statement

The ```while``` statement is used to execute a suite zero or more times, the number of times depending on the state of the ```while``` loop’s Boolean expression.

```
while boolean_expression:
    suite
```

The ```break``` statement switches control to the statement following the innermost loop in which the break statement appears—that is, it breaks out of the loop. The ```continue``` statement switches control to the start of the loop. Both ```break``` and ```continue``` are normally used inside if statements to conditionally change a loop’s behavior.

```py
while True:
    item = get_next_item()
    if not item:
        break
    process_item(item)
```

###### <a name="chapter1part6.3"></a>Chapter 1 - Part 6.3: The for …in Statement

Python’s ```for``` loop reuses the ```in``` keyword (which in other contexts is the membership operator), and has the following syntax:

```
for variable in iterable:
    suite
```

Just like the ```while``` loop, the ```for``` loop supports both ```break``` and ```continue```, and also has an optional ```else``` clause.

The ```variable``` is set to refer to each object in the ```iterable``` in turn. An ```iterable``` is any data type that can be iterated over, and includes strings (where the iteration is character by character), lists, tuples, and Python’s other collection data types.

```py
for country in ["Denmark", "Finland", "Norway", "Sweden"]:
    print(country)
```

```py
for letter in "ABCDEFGHIJKLMNOPQRSTUVWXYZ":
    if letter in "AEIOU":
        print(letter, "is a vowel")
    else:
        print(letter, "is a consonant")
```

In this snippet the first use of the ```in``` keyword is part of a ```for``` statement, with the variable ```letter``` taking on the values "A", "B", and so on up to "Z", changing at each iteration of the loop. On the snippet’s second line we use ```in``` again, but this time as the membership testing operator.

```
('A', 'is a vowel')
('B', 'is a consonant')
('C', 'is a consonant')
('D', 'is a consonant')
('E', 'is a vowel')
('F', 'is a consonant')
('G', 'is a consonant')
('H', 'is a consonant')
('I', 'is a vowel')
('J', 'is a consonant')
('K', 'is a consonant')
('L', 'is a consonant')
('M', 'is a consonant')
('N', 'is a consonant')
('O', 'is a vowel')
('P', 'is a consonant')
('Q', 'is a consonant')
('R', 'is a consonant')
('S', 'is a consonant')
('T', 'is a consonant')
('U', 'is a vowel')
('V', 'is a consonant')
('W', 'is a consonant')
('X', 'is a consonant')
('Y', 'is a consonant')
('Z', 'is a consonant')
```

###### <a name="chapter1part6.4"></a>Chapter 1 - Part 6.4: Basic Exception Handling

Many of Python’s functions and methods indicate errors or other important events by raising an exception. An exception is an object like any other Python object, and when converted to a string (e.g., when printed), the exception produces a message text.

```
try:
    try_suite
except exception1 as variable1:
    exception_suite1
…
except exceptionN as variableN:
    exception_suiteN
```

Note that the ```as variable``` part is optional; we may care only that a particular exception was raised and not be interested in its message text.

The logic works like this. If the statements in the ```try``` block’s suite all execute without raising an exception, the except blocks are skipped. If an exception is raised inside the ```try``` block, control is immediately passed to the suite corresponding to the first matching ```exception```—this means that any statements in the suite that follow the one that caused the exception will not be executed. If this occurs and if the ```as variable``` part is given, then inside the exception-handling suite, ```variable``` refers to the exception object.

If an exception occurs in the handling ```except``` block, or if an exception is raised that does not match any of the ```except``` blocks in the first place, Python looks for a matching ```except``` block in the next enclosing scope. The search for a suitable exception handler works outward in scope and up the call stack until either a match is found and the exception is handled, or no match is found, in which case the program terminates with an unhandled exception. In the case of an unhandled exception, Python prints a traceback as well as the exception’s message text.

```py
s = input("enter an integer: ")
try:
    i = int(s)
    print("valid integer entered:", i)
except ValueError as err:
    print(err)
```

If the user enters “3.5”, the output will be:

```
invalid literal for int() with base 10: '3.5'
```

But if they were to enter “13”, the output will be:

```
valid integer entered: 13
```

#### <a name="chapter1part7"></a>Chapter 1 - Part 7: Arithmetic Operators in Python

Python provides a full set of arithmetic operators, including binary operators for the four basic mathematical operations:```+ addition```, ```- subtraction```,```* multiplication```, and ```/ division```. In addition, many Python data types can be used with augmented assignment operators such as ```+=``` and ```*=```. The ```+```, ```-```, and ```*``` operators all behave as expected when both of their operands are integers:

```py
print(5+6) # print: 11
```

```py
print(3-7) # print: -4
```

```py
print(4*8) # print: 32
```

The division operator produces a floating-point value, not an integer; many other languages will produce an integer, truncating any fractional part. If we need an integer result, we can always convert using ```int()``` (or use the truncating division operator ```//```.

```py
print(12/3) # print: 4.0
```

```py
print(3/2) # print: 1.5
```

```py
a = 5
print(a) # print: 5
a += 8
print(a) # print: 13
```

The first point to remember is that the int data type is immutable—that is, once assigned, an int’s value cannot be changed. So, what actually happens behind the scenes when an augmented assignment operator is used on an immutable object is that the operation is performed, and an object holding the result is created; and then the target object reference is re-bound to refer to the result object rather than the object it referred to before. So, in the preceding case when the statement a += 8 is encountered, Python computes a + 8, stores the result in a new int object, and then rebinds a to refer to this new int. (And if the original object a was referring to has no more object references referring to it, it will be scheduled for garbage collection.) Figure 1.3 illustrates this point.

Python overloads (i.e., reuses for a different data type) the + and += operators for both strings and lists, the former meaning concatenation and the latter meaning append for strings and extend (append another list) for lists:

```py
name = "John"
print(name + "Doe") # print: 'JohnDoe'
name += " Doe"
print(name) # print: 'John Doe'
```

Like integers, strings are immutable, so when += is used a new string is created and the expression’s left-hand object reference is re-bound to it, exactly as described earlier for ints.

Lists support the same syntax but are different behind the scenes:

```py
seeds = ["sesame", "sunflower"]
seeds += ["pumpkin"]
print(seeds) # print: ['sesame', 'sunflower', 'pumpkin']
```

Since lists are mutable, when += is used the original list object is modified, so no rebinding of seeds is necessary.

The right-hand operand for the list += operator must be an iterable; if it is not an exception is raised:

```py
seeds += 5
```

```
Traceback (most recent call last):
...
TypeError: 'int' object is not iterable
```

The correct way to extend a list is to use an iterable object, such as a list:

```py
seeds += [5]
print(seeds) # print: ['sesame', 'sunflower', 'pumpkin', 5]

And of course, the iterable object used to extend the list can itself have more than one item:

```py
seeds += [9, 1, 5, "poppy"]
print(seeds) # print: ['sesame', 'sunflower', 'pumpkin', 5, 9, 1, 5, 'poppy'] 
```

Appending a plain string—for example, "durian"—rather than a list containing a string, ["durian"], leads to a logical but perhaps surprising result:

```py
seeds = ["sesame", "sunflower", "pumpkin"]
seeds += "durian"
print(seeds) # print: ['sesame', 'sunflower', 'pumpkin', 'd', 'u', 'r', 'i', 'a', 'n']
```

The list += operator extends the list by appending each item of the iterable it is provided with; and since a string is an iterable, this leads to each character in the string being appended individually. If we use the list append() method, the argument is always added as a single item.

#### <a name="chapter1part8"></a>Chapter 1 - Part 8: Input/Output in Python

Python provides the built-in ```input()``` function to accept input from the user. This function takes an optional string argument (which it prints on the console); it then waits for the user to type in a response and to finish by pressing ```Enter (or Return)```. If the user does not type any text but just presses Enter, the ```input()``` function returns an empty string; otherwise, it returns a string containing what the user typed, without any line terminator.

```py
print("Type integers, each followed by Enter; or just Enter to finish")
total = 0
count = 0
while True:
    try:
        line = input("integer: ")
        if line:
            try:
                number = int(line)
            except ValueError as err:
                break
                continue
            total += number
            count += 1
    except Exception:
        break

if count:
    print("count =", count, "total =", total, "mean =", total / count)
```

```
integer: 1
integer: 2
integer: 3
integer: 
('count =', 3, 'total =', 6, 'mean =', 2)
```

#### <a name="chapter1part9"></a>Chapter 1 - Part 9: Creating and Calling Functions in Python

Python provides a means of encapsulating suites as functions which can be parameterized by the arguments they
are passed. Here is the general syntax for creating a function:

```
def functionName(arguments):
    suite
```

The ```arguments``` are optional and multiple arguments must be comma-separated.
Every Python function has a return value; this defaults to ```None``` unlesswe return
from the function using the syntax ```return value```, in which case ```value``` is returned.
The return value can be just one value or a tuple of values. The return value can be ignored by the caller, in which case it is simply thrown away.

Note that ```def``` is a statement that works in a similar way to the assignment operator. When def is executed a function object is created and an object reference with the specified name is created and set to refer to the function object. Since functions are objects, they can be stored in collection data types and passed as arguments to other functions, as we will see in later chapters.

One frequent need when writing interactive console applications is to obtain an integer from the user. Here is a function that does just that:

```py
def get_int(msg):
    while True:
        try:
            i = int(input(msg))
            return i
        except ValueError as err:
            print(err)
```

This function takes one argument, ```msg```. Inside the ```while``` loop the user is prompted to enter an integer. If they enter something invalid a ```ValueError``` exception will be raised, the error message will be printed, and the loop will repeat. Once a valid integer is entered, it is returned to the caller. Here is how we would call it:

```py
age = get_int("enter your age: ")
```

A Python module is just a .py file that contains Python code, such as custom function and class (custom data type) definitions, and sometimes variables. To access the functionality in a module we must import it.

```py
import sys
```

Once a module has been imported, we can access any functions, classes, or variables that it contains. For example:

```py
print(sys.argv)
```

Let us look at just one example, the random module (in the standard library’s random.py file), which provides many useful functions:

```py
import random
x = random.randint(1, 6)
y = random.choice(["apple", "banana", "cherry", "durian"])
```

## <a name="chapter2"></a>Chapter 2: Data Types

Python Data types are the classification or categorization of data items. It represents the kind of value that tells what operations can be performed on a particular data. Since everything is an object in Python programming, Python data types are classes and variables are instances (objects) of these classes. The following are the standard or built-in data types in Python:

<br>

<div align="center"><img src="img/pythondatatype-w822-h505.png" width=822 height=505><br><sub>Python Data Types - (<a href='https://www.geeksforgeeks.org/python-data-types/'>Work by Geeks for Geeks</a>) </sub></div>

<br>

- Text Type: ```str```
- Numeric Types: ```int```, ```float```, ```complex```
- Sequence Types: ```list```, ```tuple```, ```range```
- Mapping Type: ```dict```
- Set Types: ```set```, ```frozenset```
- Boolean Type: ```bool```
- Binary Types: ```bytes```, ```bytearray```, ```memoryview```
- None Type: ```NoneType```

To define the values ​​of various data types of Python and check their data types we use the ```type()``` function.

```py
route = 866
print(route, type(route)) # prints: 866 <class 'int'>
```

```py
route = "North"
print(route, type(route)) # prints: North <class 'str'>
```

#### <a name="chapter2part1"></a>Chapter 2 - Part 1: Identifiers and Keywords

The names we give to our object references are called ```identifiers``` or just ```plain names```.

Identifiers are case sensitive, so for example, ```TAXRATE```, ```Taxrate```, ```TaxRate```, ```taxRate```, and ```taxrate``` are five different identifiers.

The second rule is that no identifier can have the same name as one of Python’s keywords, so we cannot use any of the names shown bellow

| Keywords          | Description                                                                                                                                                 | 
| :---------------- | :----------------------------------------------------------------------------------------------------------------------------------------------------------:|
| and               | This is a logical operator which returns true if both the operands are true else returns false.                                                             |
| or                | This is also a logical operator which returns true if anyone operand is true else returns false.                                                            |             
| not               | This is again a logical operator it returns True if the operand is false else returns false.                                                                |
| if                | This is used to make a conditional statement.                                                                                                               |
| elif              | Elif is a condition statement used with an if statement. The elif statement is executed if the previous conditions were not true.                           |
| else              | Else is used with if and elif conditional statements. The else block is executed if the given condition is not true.                                        |
| for               | This is used to create a loop.                                                                                                                              |
| while             | This keyword is used to create a while loop.                                                                                                                |
| break             | This is used to terminate the loop.                                                                                                                         |
| as                | This is used to create an alternative.                                                                                                                      |
| def               | It helps us to define functions.                                                                                                                            |
| lambda            | It is used to define the anonymous function.                                                                                                                |
| pass              | This is a null statement which means it will do nothing.                                                                                                    |
| return            | It will return a value and exit the function.                                                                                                               |
| True              | This is a boolean value.                                                                                                                                    |
| False             | This is also a boolean value.                                                                                                                               |
| try               | It makes a try-except statement.                                                                                                                            |
| with              | The with keyword is used to simplify exception handling.                                                                                                    |
| assert            | This function is used for debugging purposes. Usually used to check the correctness of code                                                                 |
| class             | It helps us to define a class.                                                                                                                              |
| continue          | It continues to the next iteration of a loop                                                                                                                |
| del               | It deletes a reference to an object.                                                                                                                        |
| except            | Used with exceptions, what to do when an exception occurs                                                                                                   |
| finally           | Finally is used with exceptions, a block of code that will be executed no matter if there is an exception or not.                                           |
| from              | It is used to import specific parts of any module.                                                                                                          |
| global            | This declares a global variable.                                                                                                                            |
| import            | This is used to import a module.                                                                                                                            |
| in                | It’s used to check whether a value is present in a list, range, tuple, etc.                                                                                 |
| is                | This is used to check if the two variables are equal or not.                                                                                                |
| none              | This is a special constant used to denote a null value or avoid. It’s important to remember, 0, any empty container(e.g empty list) do not compute to None  |
| nonlocal          | It’s declared a non-local variable.                                                                                                                         |
| raise             | This raises an exception.                                                                                                                                   |
| yield             | It ends a function and returns a generator.                                                                                                                 |
| async             | It is used to create asynchronous coroutine.                                                                                                                |
| await             | It releases the flow of control back to the event loop.                                                                                                     |

The first convention is: Don’t use the names of any of Python’s predefined identifiers for your own identifiers. So, avoid using ```NotImplemented``` and ```Ellipsis```, and the name of any of Python’s built-in data types (such as ```int```, ```float```, ```list```, ```str```, and ```tuple```), and any of Python’s built-in functions or exceptions. How can we tell whether an identifier falls into one of these categories? Python has a built-in function called ```dir()``` that returns a list of an object’s attributes. If it is called with no arguments it returns the list of Python’s built-in attributes. For example:

```py
print(dir())
```

```
['__builtins__', '__doc__', '__file__', '__name__', '__package__']
```

The ```__builtins__``` attribute is, in effect, a module that holds all of Python’s built-in attributes. We can use it as an argument to the dir() function:

```py
print(dir(__builtins__))
```

```
['ArithmeticError', 'AssertionError', 'AttributeError', 'BaseException', 'BufferError', 'BytesWarning', 'DeprecationWarning', 'EOFError', 'Ellipsis', 'EnvironmentError', 'Exception', 'False', 'FloatingPointError', 'FutureWarning', 'GeneratorExit', 'IOError', 'ImportError', 'ImportWarning', 'IndentationError', 'IndexError', 'KeyError', 'KeyboardInterrupt', 'LookupError', 'MemoryError', 'NameError', 'None', 'NotImplemented', 'NotImplementedError', 'OSError', 'OverflowError', 'PendingDeprecationWarning', 'ReferenceError', 'RuntimeError', 'RuntimeWarning', 'StandardError', 'StopIteration', 'SyntaxError', 'SyntaxWarning', 'SystemError', 'SystemExit', 'TabError', 'True', 'TypeError', 'UnboundLocalError', 'UnicodeDecodeError', 'UnicodeEncodeError', 'UnicodeError', 'UnicodeTranslateError', 'UnicodeWarning', 'UserWarning', 'ValueError', 'Warning', 'WindowsError', 'ZeroDivisionError', '__debug__', '__doc__', '__import__', '__name__', '__package__', 'abs', 'all', 'any', 'apply', 'basestring', 'bin', 'bool', 'buffer', 'bytearray', 'bytes', 'callable', 'chr', 'classmethod', 'cmp', 'coerce', 'compile', 'complex', 'copyright', 'credits', 'delattr', 'dict', 'dir', 'divmod', 'enumerate', 'eval', 'execfile', 'exit', 'file', 'filter', 'float', 'format', 'frozenset', 'getattr', 'globals', 'hasattr', 'hash', 'help', 'hex', 'id', 'input', 'int', 'intern', 'isinstance', 'issubclass', 'iter', 'len', 'license', 'list', 'locals', 'long', 'map', 'max', 'memoryview', 'min', 'next', 'object', 'oct', 'open', 'ord', 'pow', 'print', 'property', 'quit', 'range', 'raw_input', 'reduce', 'reload', 'repr', 'reversed', 'round', 'set', 'setattr', 'slice', 'sorted', 'staticmethod', 'str', 'sum', 'super', 'tuple', 'type', 'unichr', 'unicode', 'vars', 'xrange', 'zip']
```

The second convention concerns the use of underscores (_). Names that begin and end with two underscores (such as ```__lt__```) should not be used. Python defines various special methods and variables that use such names

#### <a name="chapter2part2"></a>Chapter 2 - Part 2: Integral Types

Python provides two built-in integral types, ```int``` and ```bool```. Both integers and Booleans are immutable.

When used in Boolean expressions, ```0``` and ```False``` are ```False```, and any other ```integer``` and ```True``` are ```True```. When used in numerical expressions ```True``` evaluates to ```1``` and ```False``` to ```0```.

###### <a name="chapter2part2.1"></a>Chapter 2 - Part 2.1: Integers

The size of an integer is limited only by the machine’s memory.

Above, we can check the numeric operations

| Syntax        | Description                                                                                                                                                                            | 
| :------------ | :-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------:|
| x + y         | Adds number x and number y                                                                                                                                                             |
| x - y         | Subtracts y from x                                                                                                                                                                     |
| x * y         | Multiplies x by y                                                                                                                                                                      |
| x / y         | Divides x by y; always produces a ```float``` (or a complex if x or y is ```complex```)                                                                                                |
| x // y        | Divides x by y; truncates any fractional part so always produces an ```int``` result; see also the ```round()``` function                                                              |
| x % y         | Produces the modulus (remainder) of dividing x by y                                                                                                                                    |
| x ** y        | Raises x to the power of y; see also the ```pow()``` functions                                                                                                                         |
| -x            | Negates x; changes x’s sign if nonzero, does nothing if zero                                                                                                                           |
| +x            | Does nothing; is sometimes used to clarify code                                                                                                                                        |
| abs(x)        | Returns the absolute value of x                                                                                                                                                        |
| divmod(x, y)  | Returns the quotient and remainder of dividing x by y as a tuple of two ```ints```                                                                                                     |
| pow(x, y)     | Raises x to the power of y; the same as the ** operator                                                                                                                                |
| pow(x, y, z)  | A faster alternative to (x ** y) % z                                                                                                                                                   |
| round(x, n)   | Returns x rounded to n integral digits if n is a negative int or returns x rounded to n decimal places if n is a positive int; the returned value has the same type as x; see the text |

Integer Conversion Functions

| Syntax        | Description                                                                                                                                                                                    | 
| :------------ | :---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------:|
| bin(i)        | Returns the binary representation of int i as a string, e.g., ```bin(1980) == '0b11110111100'```                                                                                               |
| hex(i)        | Returns the hexadecimal representation of i as a string, e.g., ```hex(1980) == '0x7bc'```                                                                                                      |             
| int(x)        | Converts object x to an integer; raises ```ValueError``` on failure—or ```TypeError``` if x’s data type does not support integer conversion. If x is a floating-point number it is truncated.  |
| int(s, base)  | Converts ```str s``` to an integer; raises ```ValueError``` on failure. If the optional ```base``` argument is given it should be an integer between 2 and 36 inclusive.                       |
| oct(i)        | Returns the octal representation of i as a string, e.g., ```oct(1980) == '0o3674'```                                                                                                           |

Binary numbers are written with a leading 0b, octal numbers with a leading 0o, and hexadecimal numbers with a leading 0x. Uppercase letters can also be used.

```py
print(14600926) # decimal 14600926
print(0b110111101100101011011110) # binary 14600926
print(0o67545336) # octal 14600926
print(0xDECADE) # hexadecimal 14600926
```

Objects can be created by assigning literals to variables, for example, x = 17, or by calling the relevant data type as a function, for example, x = int(17). Some objects (e.g., those of type decimal.Decimal) can be created only by using the data type since they have no literal representation. When an object is created using its data type there are three possible use cases.

An object with a default value is created—for example, x = int() creates an integer of value 0. All the built-in types can be called with no arguments.

###### <a name="chapter2part2.2"></a>Chapter 2 - Part 2.2: Booleans

There are two built-in Boolean objects: True and False. Like all other Python data types (whether built-in, library, or custom), the bool data type can be called as a function. With no arguments it returns False, with a bool argument
it returns a copy of the argument, and with any other argument it attempts to convert the given object to a bool.

All the built-in and standard library data types can be converted to produce a Boolean value.

Python provides three logical operators: ```and```, ```or```, and ```not```.

```py
t = True
f = False
print(t and f) # False
print(t and True) # True
```

###### <a name="chapter2part2.3"></a>Chapter 2 - Part 2.3: Integer Bitwise Operators

Integer Bitwise Operators

| Syntax      | Description                                                                                           | 
| :---------- | :----------------------------------------------------------------------------------------------------:|
| i &#166; j  | Bitwise OR of int i and int j; negative numbers are assumed to b represented using 2’s complement     |
| i ^ j       | Bitwise XOR (exclusive or) of i and j                                                                 |             
| i & j       | Bitwise AND of i and j                                                                                |
| i << j      | Shifts i left by j bits; like i * (2 ** j) without overflow checking                                  |
| i >> j      | Shifts i right by j bits; like i // (2 ** j) without overflow checking                                |
| ~i          | Inverts i’s bits                                                                                      |

#### <a name="chapter2part3"></a>Chapter 2 - Part 3: Floating-Point Types

Python provides three kinds of floating-point values: the built-in ```float``` and ```complex``` types,and the ```decimal.Decimal``` type from the standard library.

All three are immutable.

```py
print(0.0) # 0.0
print(5.4) # 5.4
print(-2.5) # -2.5
print(8.9e-4) # 0.00089
```

###### <a name="chapter2part3.1"></a>Chapter 2 - Part 3.1: Floating-Point Numbers

The float data type can be called as a function with no arguments it returns 0.0,

```py
x = float()
print(x) # 0.0
```

With any other argument it attempts to convert the given object to a float

```py
x = float(1)
print(x) # 1.0
```

We can convert strings to floats

```py
x = float('1')
print(x) # 1.0
```

It is possible that NaN (“not a number”) or “infinity” may be produced by a calculation involving floats

Here is a simple function for comparing floats for equality to the limit of the machine’s accuracy:

```py
import sys

def equal_float(a, b):
    return abs(a - b) <= sys.float_info.epsilon

print(sys.float_info.epsilon) # 2.22044604925e-16

print(equal_float(1.0, 0.9999999999999999999999999999999999999999999999)) # True

print(equal_float(1.0, 0.99999999)) # False
```

```sys.float_info.epsilon``` is effectively the smallest difference that the machine can distinguish between two floating-point numbers.

Floating-point numbers can be converted to integers using the ```int()``` function which returns the whole part and throws away the fractional part, or using ```round()``` which accounts for the fractional part, or using ```math.floor()``` or ```math.ceil()``` which convert down to or up to the nearest integer.

```py
import math

y = 1.6

print(int(y)) # 1
print(round(y)) # 2.0
print(math.ceil(y)) # 2.0
```

For more Mathematical functions provided by Python, you can check her

[math — Mathematical functions](https://docs.python.org/3/library/math.html)

###### <a name="chapter2part3.2"></a>Chapter 2 - Part 3.2: Complex Numbers

The ```complex``` data type is an immutable type that holds a pair of ```floats```, one representing the real part and the other the imaginary part of a complex number.

```py
z = -89.5+2.125j

print(z.real) # -89.5
print(z.imag) #  2.125
```

Except for ```//, %, divmod()```, and the three-argument ```pow()```, all the numeric operators and functions in numeric operations table

The functions in the ```math module``` do not work with complex numbers. Users of complex numbers can import the ```cmath``` module

###### <a name="chapter2part3.3"></a>Chapter 2 - Part 3.3: Decimal Numbers

There are several different numeric data types in Python, including int, float, and complex numbers, but due to floating point numbers' machine-dependent nature, we need a more precise data type.

With the Python decimal module, decimal floating point arithmetic is carried out at high speed. In Python, numbers that contain decimal points are always treated as double-precision floating-point numbers. Decimal points have a smaller range than floats, but more precision. For monetary and financial calculations, it is appropriate. Also, it is more similar to how humans handle numbers.

Decimal modules have a precision that can be adjusted to any size necessary for a given problem, unlike hardware-based binary floating points.

```py
from decimal import Decimal
i = 8
j = 9
k = i / j
d = Decimal(i) / Decimal(j)
print (k, type(k)) # 0.8888888888888888 <class 'float'>
print (d, type(d)) # (Decimal('0.8888888888888888888888888889'), <class 'decimal.Decimal'>)
```
This output shows that float type objects have less precision than decimal type objects because their approximation method is much more aggressive. 

Unlike hardware based binary floating point, the decimal module has a user alterable precision (defaulting to 28 places) which can be as large as needed for a given problem:

```py
from decimal import *

getcontext().prec = 6
print(Decimal(1) / Decimal(7)) # 0.142857

getcontext().prec = 28
print(Decimal(1) / Decimal(7)) # 0.1428571428571428571428571429
```

#### <a name="chapter2part4"></a>Chapter 2 - Part 4: Strings

Strings are represented by the immutable ```str``` data type which holds a sequence of Unicode characters.

The str data type can be called as a function to create string objects

- with no arguments it returns an empty string
- with a nonstring argument it returns the string form of the argument
- with a string argument it returns a copy of the string

```py
x = str() 

y = str(1) 

z = str('abc') 

print(x) #
print(y) # 1
print(z) # abc
```

Strings can be delimited by double or single quotes, as long as the same kind are used at both ends, and since Python uses Unicode, strings are not limited to ASCII characters, as the penultimate string shows. An empty string is simply one with nothing between the delimiters.

```
"Infinitely Demanding"
'Simon Critchley'
'positively αβγ ÷©'
''
```

we can use a triple quoted string

```
text = """A triple quoted string like this can include 'quotes' and "quotes" without formality. We can also escape 
newlines \ so this particular string is actually only two lines long."""
```

If we want to use quotes inside a normal quoted string we can do so without formality if they are different from the delimiting quotes; otherwise, we must escape them:

```py
a = "Single 'quotes' are fine; \"doubles\" must be escaped."
b = 'Single \'quotes\' must be escaped; "doubles" are fine.'

print(a) # Single 'quotes' are fine; "doubles" must be escaped.
print(b) # Single 'quotes' must be escaped; "doubles" are fine.
```

Since ```.py``` files default to using the UTF-8 Unicode encoding, we can write any Unicode characters in our string literals without formality.

```py
print u'\u0420\u043e\u0441\u0441\u0438\u044f' # Россия
```

If we want to know the Unicode code point (the integer assigned to the character in the Unicode encoding) for a particular character in a string, we can use the built-in ```ord()```

```py
print(ord('t')) # 116

print(hex(ord('t'))) # 0x74
```

Similarly, we can convert any integer that represents a valid code point into the corresponding Unicode character using the built-in ```chr()``` function

```py
s = "anarchists are " + chr(8734) + chr(0x23B7)

print(s)
```

Python’s String Escapes

| Syntax      | Meaning                                                              | 
| :---------- | :-------------------------------------------------------------------:|
| \newline    | Escape (i.e., ignore) the newline                                    |
| \\          | Backslash (\)                                                        |             
| \'          | Single quote (’)                                                     |
| \"          | Double quote (")                                                     |
| \a          | ASCII bell (BEL)                                                     |
| \b          | ASCII backspace (BS)                                                 |
| \f          | ASCII formfeed (FF)                                                  |
| \n          | ASCII linefeed (LF)                                                  |
| \N{name}    | Unicode character with the given name                                |
| \ooo        | Character with the given octal value                                 |
| \r          | ASCII carriage return (CR)                                           |
| \t          | ASCII tab (TAB)                                                      |
| \uhhhh      | Unicode character with the given 16-bit hexadecimal value            |
| \Uhhhhhhhh  | Unicode character with the given 32-bit hexadecimal value            |
| \v          | ASCII vertical tab (VT)                                              |
| \xhh        | Character with the given 8-bit hexadecimal value                     |

###### <a name="chapter2part4.1"></a>Chapter 2 - Part 4.1: Comparing Strings

There is six ways to comparing strings in Python (```<, <=, ==, !=, >, and >=.```)

```py
print("Geek" == "Geek") # True
print("Geek" < "geek") # True
print("Geek" > "geek") # False
print("Geek" != "Geek") # False
```

- The ```==``` operator compares the values of both operands and checks for value equality. The same is the case for ```!=```

```py
print("Geek" == "Geek") # True
print("Geek" != "Geek") # False
```

- Whereas ```is``` operator checks whether both the operands refer to the same object or not. In this case, the id(). The same for ```is not```

```py
str1 = "Geek"
str2 = "Geek"
str3 = str1
 
print("ID of str1 =", hex(id(str1))) # ID of str1 = 0x7f6037051570
print("ID of str2 =", hex(id(str2))) # ID of str2 = 0x7f6037051570
print("ID of str3 =", hex(id(str3))) # ID of str3 = 0x7f6037051570
print(str1 is str1) # True
print(str1 is str2) # True
print(str1 is str3) # True
 
str1 += "s"
str4 = "Geeks"
 
print("\nID of changed str1 =", hex(id(str1))) # ID of changed str1 = 0x7f60356137d8
print("ID of str4 =", hex(id(str4))) # ID of str4 = 0x7f60356137a0
print(str1 is str4) # False
```

The operators <, <=, >, and >= returns True if the first string is lexicographically larger than the second string.

```py
str1="Hello"
str2="World"

print(str1>str2) # False
print(str1<str2) # True
print(str1>=str2) # False
print(str1<=str2) # True
```

###### <a name="chapter2part4.2"></a>Chapter 2 - Part 4.2: Slicing and Striding Strings

Index positions into a string begin at 0 and go up to the length of the string minus 1.

<br>

<div align="center"><img src="img/stringindex-w621-h272.png" width=621 height=272><br><sub>Python String Index - (<a href='https://www.geeksforgeeks.org/string-slicing-in-python/?ref=lbp'>Work by Geeks for Geeks</a>) </sub></div>

<br>

The slice operator has three syntaxes:

```
seq[start]
seq[start:end]
seq[start:end:step]
```

```py
# Python program to demonstrate
# string slicing
 
# String slicing
String = 'ASTRING'
 
# Using slice constructor
s1 = slice(3)
s2 = slice(1, 5, 2)
s3 = slice(-1, -12, -2)
 
print("String slicing") # String slicing
print(String[s1]) # AST
print(String[s2]) # SR
print(String[s3]) # GITA
```

```
arr[start:stop]         # items start through stop-1
arr[start:]             # items start through the rest of the array
arr[:stop]              # items from the beginning through stop-1
arr[:]                  # a copy of the whole array
arr[start:stop:step]    # start through not past stop, by step
```

```py
# Python program to demonstrate
# string slicing
 
# String slicing
String = 'GEEKSFORGEEKS'
 
# Using indexing sequence
print(String[:3]) # GEE
```

```py
s = "The waxwork man"

s = s[:12] + "wo" + s[12:]

print(s) # 'The waxwork woman'
```

###### <a name="chapter2part4.3"></a>Chapter 2 - Part 4.3: String Operators and Methods

Since strings are immutable sequences, all the functionality that can be used with immutable sequences can be used with strings.

As strings are sequences they are “sized” objects, and therefore we can call ```len()``` with a string as the argument.

```py
text = 'abcdf'

print(len(text)) # 5
```

We have seen that the + operator is overloaded to provide string concatenation.

```py


# Defining strings
var1 = "Hello "
var2 = "Geek"
 
# + Operator is used to combine strings
var3 = var1 + var2
print(var3) # Hello Geek
```

In cases where we want to concatenate lots of strings the str.join() method offers a better solution.

The method takes a sequence as an argument list or tuple of strings), and joins them together into a single string with the string the method was called on between each one.

```py
treatises = ["Arithmetica", "Conics", "Elements"]

print(" ".join(treatises)) # Arithmetica Conics Elements

print("".join(treatises)) # ArithmeticaConicsElements
```

The * operator provides string replication:

```py
s = "=" * 5

print(s) # =====
```

When applied to strings, the in membership operator returns True if its lefthand string argument is a substring of, or equal to, its right-hand string argument.

```py
s = 'tatio'

print('ta' in s) # True
```

In cases where we want to find the position of one string inside another, we can use 

- ```str.index()``` method; this returns the index position of the substring, or raises a ValueError exception on failure.
- ```str.find()``` method; this returns the index position of the substring, or -1 on failure.

We can check all most of the operation in the table above
 
| Escape                               | Description                                                                                                                                                                                                         | 
| :----------------------------------- | :------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------:|
|  s.capitalize()                      | Returns a copy of str s with the first letter capitalized; see also the str.title() method                                                                                                                          |
|  s.center(width, char)               | Returns a copy of s centered in a string of length width padded with spaces or optionally with char (a string of length 1); see str.ljust(), str.rjust(), and str.format()                                          |             
|  s.count(t, start, end)              | Returns the number of occurrences of str t in str s (or in the start:end slice of s)                                                                                                                                |
|  s.encode(encoding, err)             | Returns a bytes object that represents the string using the default encoding or using the specified encoding and handling errors according to the optional err argument                                             |
|  s.endswith(x, start, end)           | Returns True if s (or the start:end slice of s) ends with str x or with any of the strings in tuple x; otherwise, returns False. See also str.startswith().                                                         |
|  s.expandtabs(size)                  | Returns a copy of s with tabs replaced with spaces in multiples of 8 or of size if specified                                                                                                                        |
|  s.find(t, start, end)               | Returns the leftmost position of t in s (or in the start:end slice of s) or -1 if not found. Use str.rfind() to find the rightmost position. See also str.index().                                                  |
|  s.format(...)                       | Returns a copy of s formatted according to the given arguments.                                                                                                                                                     |
|  s.index(t, start, end)              | Returns the leftmost position of t in s (or in the start:end slice of s) or raises ValueError if not found. Use str.rindex() to search from the right. See str.find().                                              |
|  s.isalnum()                         | Returns True if s is nonempty and every character in s is alphanumeric                                                                                                                                              |
|  s.isalpha()                         | Returns True if s is nonempty and every character in s is alphabetic                                                                                                                                                |
|  s.isdecimal()                       | Returns True if s is nonempty and every character in s is a Unicode base 10 digit                                                                                                                                   |
|  s.isdigit()                         | Returns True if s is nonempty and every character in s is an ASCII digit                                                                                                                                            |
|  s.isidentifier()                    | Returns True if s is nonempty and is a valid identifier                                                                                                                                                             |
|  s.islower()                         | Returns True if s has at least one lowercaseable character and all its lowercaseable characters are lowercase; see also str.isupper()                                                                               |
|  s.isnumeric()                       | Returns True if s is nonempty and every character in s is a numeric Unicode character such as a digit or fraction                                                                                                   |
|  s.isprintable()                     | Returns True if s is empty or if every character in s is considered to be printable, including space, but not newline                                                                                               |
|  s.isspace()                         | Returns True if s is nonempty and every character in s is a whitespace character                                                                                                                                    |
|  s.istitle()                         | Returns True if s is a nonempty title-cased string; see also str.title()                                                                                                                                            |
|  s.isupper()                         | Returns True if str s has at least one uppercaseable character and all its uppercaseable characters are uppercase; see also str.islower()                                                                           |
|  s.join(seq)                         | Returns the concatenation of every item in the sequence seq, with str s (which may be empty) between each one                                                                                                       |
|  s.ljust(width, char)                | Returns a copy of s left-aligned in a string of length width padded with spaces or optionally with char (a string of length 1). Use str.rjust() to right-align and str.center() to center. See also str.format().   |
|  s.lower()                           | Returns a lowercased copy of s; see also str.upper()                                                                                                                                                                |
|  s.maketrans()                       | Companion of str.translate();                                                                                                                                                                                       |
|  s.partition(t)                      | Returns a tuple of three strings—the part of str s before the leftmost str t, t, and the part of s after t; or if t isn’t in s returns s and two empty strings.                                                     |
|  s.replace(t, u, n)                  | Returns a copy of s with every (or a maximum of n if given) occurrences of str t replaced with str u                                                                                                                |
|  s.split(t, n)                       | Returns a list of strings splitting at most n times on str t; if n isn’t given, splits as many times as possible; if t isn’t given, splits on whitespace.                                                           |
|  s.splitlines(f)                     | Returns the list of lines produced by splitting s on line terminators, stripping the terminators unless f is True                                                                                                   |
|  s.startswith(x, start, end)         | Returns True if s (or the start:end slice of s) starts with str x or with any of the strings in tuple x; otherwise, returns False. See also str.endswith().                                                         |
|  s.strip(chars)                      | Returns a copy of s with leading and trailing whitespace (or the characters in str chars) removed;str.lstrip() strips only at the start, and str.rstrip() strips only at the end                                    |
|  s.swapcase()                        | Returns a copy of s with uppercase characters lowercased and lowercase characters uppercased; see also str.lower() and str.upper()                                                                                  |
|  s.title()                           | Returns a copy of s where the first letter of each word is uppercased and all other letters are lowercased; see str.istitle()                                                                                       |
|  s.translate()                       | Companion of str.maketrans();                                                                                                                                                                                       |
|  s.upper()                           | Returns an uppercased copy of s; see also str.lower()                                                                                                                                                               |
|  s.zfill(w)                          | Returns a copy of s, which if shorter than w is padded with leading zeros to make it w characters long                                                                                                              |


###### <a name="chapter2part4.4"></a>Chapter 2 - Part 4.4: String Formatting with the str.format() Method

The ```str.format()``` method provides a very flexible and powerful way of creating strings.

```py
print("The novel '{0}' was published in {1}".format("Hard Times", 1854)) # The novel 'Hard Times' was published in 185

print("{{{0}}} {1} ;-}}".format("I'm in braces", "I'm not")) # {I'm in braces} I'm not ;-}

```

###### <a name="chapter2part4.5"></a>Chapter 2 - Part 4.5: Field Names

A field name can be either an integer corresponding to one of the str.format() method’s arguments, or the name of one of the method’s keyword arguments.

```py
print("{who} turned {age} this year".format(who="She", age=88)) # She turned 88 this year
print("The {who} was {0} last week".format(12, who="boy")) # The boy was 12 last week
```

Field names may refer to collection data types—for example, lists

```py
stock = ["paper", "envelopes", "notepads", "pens", "paper clips"]

print("We have {0[1]} and {0[2]} in stock".format(stock)) # We have envelopes and notepads in stock
```

With dictionaries

```py
d = dict(animal="elephant", weight=12000)

print("The {0[animal]} weighs {0[weight]}kg".format(d)) # The elephant weighs 12000kg
```

## <a name="chapter3"></a>Chapter 3: Collection Data Types

#### <a name="chapter3part1"></a>Chapter 3 - Part 1: Sequence Types

A ```sequence``` type is one that supports the membership operator ```(in)```, the size function ```(len())```, slices ```([])```, and is iterable.

Python provides five built-in sequence types: ```bytearray```, ```bytes```, ```list```, ```str```, and ```tuple```

###### <a name="chapter3part1.1"></a>Chapter 3 - Part 1.1: Tuples

A tuple is an ordered sequence of zero or more object references. Tuples support the same slicing and striding syntax as strings.

Here are a few examples demonstrating different ways to create and use tuples

```py
# Creating tuples
t1 = (1, 2, 3)
t2 = 'a', 'b', 'c'
t3 = (1, 'a', True)
t4 = ()
t5 = tuple('ABC')

# Single element tuple
t6 = (5,)
t7 = 5,  # also a single-element tuple

t8 = 'AA', 'BB', 'CC'

print(t1)  # Output: (1, 2, 3)
print(t2)  # Output: ('a', 'b', 'c')
print(t3)  # Output: (1, 'a', True)
print(t4)  # Output: ()
print(t5)  # Output: ('A', 'B', 'C')
print(t6)  # Output: (5,)
print(t7)  # Output: (5,)
print(t8)  # Output: ('AA', 'BB', 'CC')
```

Tuples have only two built-in methods:

**count()**: Returns the number of times a specified value appears in the tuple.

```py
my_tuple = (1, 2, 2, 3)
print(my_tuple.count(2))  # Output: 2
```

**index():** Returns the index of the first occurrence of a specified value.

```py
my_tuple = (1, 2, 3)
print(my_tuple.index(2))  # Output: 1
```

Tuples can be used with the operators ```+ (concatenation)```, ```* (replication)```, and ```[] (slice)```, and with ```in``` and ```not in``` to test for membership.

```py
# Concatenation
tuple1 = (1, 2, 3)
tuple2 = (4, 5, 6)
concatenated = tuple1 + tuple2
print("Concatenated:", concatenated)  # Output: (1, 2, 3, 4, 5, 6)

# Replication
replicated = tuple1 * 2
print("Replicated:", replicated)  # Output: (1, 2, 3, 1, 2, 3)

# Slicing
tuple1 = (1, 2, 3, 4, 5)
print(tuple1[1:3])  # Output: (2, 3)
print(tuple1[:3])   # Output: (1, 2, 3)
print(tuple1[2:])   # Output: (3, 4, 5)
print(tuple1[:])    # Output: (1, 2, 3, 4, 5)

# Membership
tuple1 = (1, 2, 3, 4, 5)

print(3 in tuple1)     # Output: True
print(6 in tuple1)     # Output: False
print(3 not in tuple1) # Output: False
print(6 not in tuple1) # Output: True
```

The ```+=``` and ```*=``` augmented assignment operators can be used even though tuples are

Like strings, tuples are immutable, so we cannot replace or delete any of their items.

```py
my_tuple = (1, 2, 3)

# This will raise a TypeError
my_tuple[0] = 4  # TypeError: 'tuple' object does not support item assignment
```

If we want to be able to modify an ordered sequence, we simply use a list instead of a tuple; or if we already have a tuple but want to modify it, we can convert it to a list using the ```list()``` conversion function and then apply the changes to the resultant list.

```py
# Original tuple
my_tuple = (1, 2, 3, 4, 5)

# Convert tuple to list
my_list = list(my_tuple)

# Modify the list
my_list[2] = 99  # Change the third element
my_list.append(6)  # Add an element at the end

# Convert list back to tuple
my_tuple = tuple(my_list)

print(my_tuple)  # Output: (1, 2, 99, 4, 5, 6)
```

Tuples can be compared using the standard comparison operators ```(<, <=, ==, !=, >=, >)```, with the comparisons being applied item by item (and recursively for nested items such as tuples inside tuples).

```py
tuple1 = (1, 2, 3)
tuple2 = (1, 2, 4)
tuple3 = (1, 2, 3)

print(tuple1 < tuple2)   # Output: True (3 < 4)
print(tuple1 <= tuple2)  # Output: True (3 < 4)
print(tuple1 == tuple3)  # Output: True (all elements are equal)
print(tuple1 != tuple2)  # Output: True (3 != 4)
print(tuple1 >= tuple3)  # Output: True (all elements are equal)
print(tuple1 > tuple2)   # Output: False (3 < 4)
```

Nested tuples are tuples that contain other tuples as elements

```py
nested_tuple = (1, (2, 3), (4, (5, 6)), 7)
```

You can access elements of nested tuples using multiple indices:

```py
nested_tuple = (1, (2, 3), (4, (5, 6)), 7)

# Accessing the first element
print(nested_tuple[0])  # Output: 1

# Accessing the second element (which is a tuple)
print(nested_tuple[1])  # Output: (2, 3)

# Accessing the first element of the second tuple
print(nested_tuple[1][0])  # Output: 2

# Accessing the third element (which is a tuple)
print(nested_tuple[2])  # Output: (4, (5, 6))

# Accessing the second element of the third tuple (which is a nested tuple)
print(nested_tuple[2][1])  # Output: (5, 6)

# Accessing the first element of the nested tuple
print(nested_tuple[2][1][0])  # Output: 5
```

Tuples can be compared lexicographically, including nested tuples. The comparison is done element by element recursively.

```py
tuple1 = (1, (2, 3), (4, (5, 6)))
tuple2 = (1, (2, 3), (4, (5, 7)))

print(tuple1 < tuple2)  # Output: True ((5, 6) < (5, 7))
print(tuple1 == tuple2) # Output: False (because (5, 6) != (5, 7))
```

Nested tuples are useful in various scenarios, such as:

**Representing Matrix or Grid Data**

```py
matrix = ((1, 2, 3), (4, 5, 6), (7, 8, 9))
```

**nested tuples to represent a 3D point**

```py
# Define a 3D point as a nested tuple
point_3d = (1, (2, (3, 4)))

# Accessing elements
x = point_3d[0]
y = point_3d[1][0]
z = point_3d[1][1][0]

print(f"Coordinates: x={x}, y={y}, z={z}")  # Output: Coordinates: x=1, y=2, z=3
```

**Iterating Over Items in a Tuple**

- Simple Iteration To iterate over each item in a tuple, you use a for loop:

```py
my_tuple = (1, 2, 3, 4, 5)

for item in my_tuple:
    print(item)
# Output:
# 1
# 2
# 3
# 4
# 5
```

- Iteration with Index To access both the index and the item, use the enumerate() function:

```py
my_tuple = ('a', 'b', 'c', 'd')

for index, item in enumerate(my_tuple):
    print(f"Index: {index}, Item: {item}")
# Output:
# Index: 0, Item: a
# Index: 1, Item: b
# Index: 2, Item: c
# Index: 3, Item: d
```

- Iterating Over Nested Tuples If you have a tuple of tuples, you can nest for loops to access the inner tuples:

```py
nested_tuple = ((1, 2), (3, 4), (5, 6))

for subtuple in nested_tuple:
    for item in subtuple:
        print(item)
# Output:
# 1
# 2
# 3
# 4
# 5
# 6
```

- Using List Comprehensions While not as common with tuples as with lists, you can use a list comprehension to transform a tuple into another tuple:

```py
my_tuple = (1, 2, 3, 4, 5)
squared = tuple(x ** 2 for x in my_tuple)
print(squared)
# Output: (1, 4, 9, 16, 25)
```

- Using map() Function Similar to list comprehensions, you can use map() to apply a function to each item in the tuple:

```py
my_tuple = (1, 2, 3, 4, 5)
squared = tuple(map(lambda x: x ** 2, my_tuple))
print(squared)
# Output: (1, 4, 9, 16, 25)
```

- Using filter() Function You can filter items based on a condition and convert the result back to a tuple:

```py
my_tuple = (1, 2, 3, 4, 5)
even_numbers = tuple(filter(lambda x: x % 2 == 0, my_tuple))
print(even_numbers)
# Output: (2, 4)
```

###### <a name="chapter3part1.2"></a>Chapter 3 - Part 1.2: Named Tuples

A named tuple is a subclass of Python's built-in ```tuple``` data type, providing named fields that you can access like attributes. Named tuples make it easier to work with tuples by allowing you to access elements using named attributes rather than relying solely on positional indexing. This improves code readability and reduces the chance of errors.

Named tuples are defined using the ```collections.namedtuple``` factory function. Here's a step-by-step guide on how to create and use named tuples

```py
from collections import namedtuple

# Define a named tuple type
Car = namedtuple('Car', ['make', 'model', 'year'])

# Create instances of Car
car1 = Car(make='Toyota', model='Corolla', year=2020)
car2 = Car(make='Honda', model='Civic', year=2022)

# Access fields
print(car1.make)   # Output: Toyota
print(car2.year)   # Output: 2022

# Convert to dictionary
car1_dict = car1._asdict()
print(car1_dict)  # Output: {'make': 'Toyota', 'model': 'Corolla', 'year': 2020}

# Replace a field value
car3 = car1._replace(year=2021)
print(car3)  # Output: Car(make='Toyota', model='Corolla', year=2021)

# Access field names
print(Car._fields)  # Output: ('make', 'model', 'year')
```

Advantages of Named Tuples can be

- Readability: Named fields make the code more readable and self-documenting.
- Immutability: Like regular tuples, named tuples are immutable.
- Attribute Access: You can access elements using named attributes instead of numeric indices, which reduces the chance of errors.
- Compatibility: Named tuples are compatible with other tuple operations and can be used in places where regular tuples are used.

Named tuples in Python come with several private methods that are used internally to support their functionality.

**_asdict()**

Purpose: Converts the named tuple to an OrderedDict where the keys are the field names and the values are the corresponding field values.

Usage: This method is useful when you need a dictionary representation of the named tuple, which can be handy for serialization or conversion to other formats.

```py
from collections import namedtuple

Person = namedtuple('Person', ['name', 'age', 'city'])
person = Person(name='Alice', age=30, city='New York')

person_dict = person._asdict()
print(person_dict)  # Output: {'name': 'Alice', 'age': 30, 'city': 'New York'}
```

**_replace(**kwargs)**

Purpose: Returns a new named tuple instance with specified fields replaced by new values. The original named tuple remains unchanged.

Usage: This method is useful when you want to create a modified copy of a named tuple without altering the original instance.

```py
Person = namedtuple('Person', ['name', 'age', 'city'])
person = Person(name='Alice', age=30, city='New York')

new_person = person._replace(age=31)
print(new_person)  # Output: Person(name='Alice', age=31, city='New York')
```

**_fields**

Purpose: A tuple of field names for the named tuple. It provides the names of the fields in the named tuple.

Usage: This attribute is read-only and is useful for introspection, allowing you to programmatically access the field names.

```py
Person = namedtuple('Person', ['name', 'age', 'city'])
print(Person._fields)  # Output: ('name', 'age', 'city')
```


###### <a name="chapter3part1.3"></a>Chapter 3 - Part 1.3: Lists

A list in Python is an ordered sequence of zero or more object references. Unlike tuples, lists are mutable, which means their elements can be changed after they are created. Lists support the same slicing and striding syntax as strings and tuples.

Here are a few examples demonstrating different ways to create and use lists:

```py
# Creating lists
l1 = [1, 2, 3]
l2 = ['a', 'b', 'c']
l3 = [1, 'a', True]
l4 = []
l5 = list('ABC')

# Single element list
l6 = [5]

# Nested lists
l7 = ['AA', 'BB', 'CC']

print(l1)  # Output: [1, 2, 3]
print(l2)  # Output: ['a', 'b', 'c']
print(l3)  # Output: [1, 'a', True]
print(l4)  # Output: []
print(l5)  # Output: ['A', 'B', 'C']
print(l6)  # Output: [5]
print(l7)  # Output: ['AA', 'BB', 'CC']
```

Lists have several built-in methods:

- append(): Adds an element at the end of the list.

```py
my_list = [1, 2, 3]
my_list.append(4)
print(my_list)  # Output: [1, 2, 3, 4]
```

- extend(): Extends the list by appending all the items from an iterable.

```py
my_list = [1, 2, 3]
my_list.extend([4, 5])
print(my_list)  # Output: [1, 2, 3, 4, 5]
```

- insert(): Inserts an element at a specified position.

```py
my_list = [1, 2, 3]
my_list.insert(1, 'a')
print(my_list)  # Output: [1, 'a', 2, 3]
```

- remove(): Removes the first occurrence of a specified value.

```py
my_list = [1, 2, 3, 2]
my_list.remove(2)
print(my_list)  # Output: [1, 3, 2]
```

- pop(): Removes and returns the element at a specified position. If no index is specified, it removes and returns the last item.

```py
my_list = [1, 2, 3]
print(my_list.pop(1))  # Output: 2
print(my_list)  # Output: [1, 3]
```

- index(): Returns the index of the first occurrence of a specified value.

```py
my_list = [1, 2, 3]
print(my_list.index(2))  # Output: 1
```

- count(): Returns the number of times a specified value appears in the list.

```py
my_list = [1, 2, 2, 3]
print(my_list.count(2))  # Output: 2
```

- sort(): Sorts the list in ascending order. It can also take a reverse parameter to sort in descending order.

```py
my_list = [3, 1, 2]
my_list.sort()
print(my_list)  # Output: [1, 2, 3]
my_list.sort(reverse=True)
print(my_list)  # Output: [3, 2, 1]
```

- reverse(): Reverses the order of the list.

```py
my_list = [1, 2, 3]
my_list.reverse()
print(my_list)  # Output: [3, 2, 1]
```

- copy(): Returns a shallow copy of the list.

```py
my_list = [1, 2, 3]
my_copy = my_list.copy()
print(my_copy)  # Output: [1, 2, 3]
```

- clear(): Removes all elements from the list.

```py
my_list = [1, 2, 3]
my_list.clear()
print(my_list)  # Output: []
```

Lists can be used with the operators + (concatenation), * (replication), and [] (slice), and with in and not in to test for membership.

```py
# Concatenation
list1 = [1, 2, 3]
list2 = [4, 5, 6]
concatenated = list1 + list2
print("Concatenated:", concatenated)  # Output: [1, 2, 3, 4, 5, 6]

# Replication
replicated = list1 * 2
print("Replicated:", replicated)  # Output: [1, 2, 3, 1, 2, 3]

# Slicing
list1 = [1, 2, 3, 4, 5]
print(list1[1:3])  # Output: [2, 3]
print(list1[:3])   # Output: [1, 2, 3]
print(list1[2:])   # Output: [3, 4, 5]
print(list1[:])    # Output: [1, 2, 3, 4, 5]

# Membership
list1 = [1, 2, 3, 4, 5]

print(3 in list1)     # Output: True
print(6 in list1)     # Output: False
print(3 not in list1) # Output: False
print(6 not in list1) # Output: True
```

Lists are mutable, so we can replace or delete any of their items:

```py
my_list = [1, 2, 3]
my_list[0] = 4
print(my_list)  # Output: [4, 2, 3]

del my_list[1]
print(my_list)  # Output: [4, 3]
```

Lists can be compared using the standard comparison operators (<, <=, ==, !=, >=, >), with the comparisons being applied item by item (and recursively for nested items such as lists inside lists).

```py
list1 = [1, 2, 3]
list2 = [1, 2, 4]
list3 = [1, 2, 3]

print(list1 < list2)   # Output: True (3 < 4)
print(list1 <= list2)  # Output: True (3 < 4)
print(list1 == list3)  # Output: True (all elements are equal)
print(list1 != list2)  # Output: True (3 != 4)
print(list1 >= list3)  # Output: True (all elements are equal)
print(list1 > list2)   # Output: False (3 < 4)
```

Nested lists are lists that contain other lists as elements. You can access elements of nested lists using multiple indices

```py
nested_list = [1, [2, 3], [4, [5, 6]], 7]

# Accessing the first element
print(nested_list[0])  # Output: 1

# Accessing the second element (which is a list)
print(nested_list[1])  # Output: [2, 3]

# Accessing the first element of the second list
print(nested_list[1][0])  # Output: 2

# Accessing the third element (which is a list)
print(nested_list[2])  # Output: [4, [5, 6]]

# Accessing the second element of the third list (which is a nested list)
print(nested_list[2][1])  # Output: [5, 6]

# Accessing the first element of the nested list
print(nested_list[2][1][0])  # Output: 5
```

Lists can be compared lexicographically, including nested lists. The comparison is done element by element recursively.

```py
list1 = [1, [2, 3], [4, [5, 6]]]
list2 = [1, [2, 3], [4, [5, 7]]]

print(list1 < list2)  # Output: True ([5, 6] < [5, 7])
print(list1 == list2) # Output: False (because [5, 6] != [5, 7])
```

**Iterating Over Items in a List**

- Basic Iteration: To iterate over each element in a list, we use a for loop:

```py
# Basic Iteration
my_list = [1, 2, 3, 4, 5]

for item in my_list:
    print(item)
# Output:
# 1
# 2
# 3
# 4
# 5
```

```py
# Incrementing each element in a list by 1 using index
numbers = [1, 2, 3, 4, 5]

for i in range(len(numbers)):
    numbers[i] += 1

print(numbers)
# Output: [2, 3, 4, 5, 6]
```

- Iteration with Index: Sometimes we need both the index and the value of each element in the list. We can use the enumerate function to achieve this:

```py
# Iteration with Index
my_list = ['a', 'b', 'c', 'd']

for index, item in enumerate(my_list):
    print(f"Index: {index}, Item: {item}")
# Output:
# Index: 0, Item: a
# Index: 1, Item: b
# Index: 2, Item: c
# Index: 3, Item: d
```

- Iterating Over Nested Lists: When dealing with nested lists, we may need to use nested for loops to access inner elements:

```py
# Iterating Over Nested Lists
nested_list = [[1, 2], [3, 4], [5, 6]]

for sublist in nested_list:
    for item in sublist:
        print(item)
# Output:
# 1
# 2
# 3
# 4
# 5
# 6
```

- Using List Comprehensions: List comprehensions provide a concise way to iterate over lists and perform operations on their elements:

```py
# Using List Comprehensions
my_list = [1, 2, 3, 4, 5]
squared = [item ** 2 for item in my_list]
print(squared)
# Output: [1, 4, 9, 16, 25]
```

- Using the map Function: The map function applies a specified function to each item in the list:

```py
# Using the map Function
my_list = [1, 2, 3, 4, 5]
squared = list(map(lambda x: x ** 2, my_list))
print(squared)
# Output: [1, 4, 9, 16, 25]
```

- Using the filter Function: The filter function creates a list of elements for which a specified function returns True:

```py
# Using the filter Function
my_list = [1, 2, 3, 4, 5]
even_numbers = list(filter(lambda x: x % 2 == 0, my_list))
print(even_numbers)
# Output: [2, 4]
```

- Iterating Over a List of Dictionaries:

```py
# Iterating Over a List of Dictionaries
students = [
    {"name": "Alice", "age": 24},
    {"name": "Bob", "age": 22},
    {"name": "Charlie", "age": 23}
]

for student in students:
    print(f"Name: {student['name']}, Age: {student['age']}")
# Output:
# Name: Alice, Age: 24
# Name: Bob, Age: 22
# Name: Charlie, Age: 23
```

###### <a name="chapter3part1.4"></a>Chapter 3 - Part 1.4: List Comprehensions

A list comprehension is an expression and a loop with an optional condition enclosed in brackets where the loop is used to generate items for the list, and where the condition can filter out unwanted items. The simplest form of a list comprehension is this:

```[item for item in iterable]```

This will return a list of every item in the iterable, and is semantically no different from list(iterable). Two things that make list comprehensions more interesting and powerful are that we can use expressions, and we can attach a condition—this takes us to the two general syntaxes for list comprehensions:

```[expression for item in iterable]```

```[expression for item in iterable if condition]```

The second syntax is equivalent to:

```
temp = []
for item in iterable:
	if condition:
		temp.append(expression)
```

- Basic List Comprehension

```py
numbers = [1, 2, 3, 4, 5]
all_numbers = [n for n in numbers]
print(all_numbers)
# Output: [1, 2, 3, 4, 5]
```

- List Comprehension with Expression

```py
numbers = [1, 2, 3, 4, 5]
squared = [n ** 2 for n in numbers]
print(squared)
# Output: [1, 4, 9, 16, 25]
```

- List Comprehension with Condition

```py
numbers = [1, 2, 3, 4, 5]
even_squared = [n ** 2 for n in numbers if n % 2 == 0]
print(even_squared)
# Output: [4, 16]
```


#### <a name="chapter3part2"></a>Chapter 3 - Part 2: Set Types

A ```set``` type is a collection data type that supports the membership operator ```(in)```, the size function ```(len())```, and is iterable. In addition, set types at least provide a ```set.isdisjoint()``` method.

Python provides two built-in set types: the ```mutable set``` type and the ```immutable frozenset```. When iterated, set types provide their items in an arbitrary order.

Only ```hashable``` objects may be added to a set. Hashable objects are objects which have a ```__hash__()``` special method whose return value is always the same throughout the object’s lifetime, and which can be compared for equality using the ```__eq__()``` special method.

All the built-in immutable data types, such as ```float```, ```frozenset```, ```int```, ```str```, and ```tuple```, are hashable and can be added to sets. The built-in mutable data types, such as ```dict```, ```list```, and ```set```, are not hashable since their hash value changes depending on the items they contain, so they cannot be added to sets.

###### <a name="chapter3part2.1"></a>Chapter 3 - Part 2.1: Sets

A set is an unordered collection of zero or more object references that refer to hashable objects. Sets are mutable, so we can easily add or remove items, but since they are unordered they have no notion of index position and so cannot be sliced or strided.

Here are a few examples demonstrating different ways to create and use sets:

```py
# Creating sets
s1 = {1, 2, 3}
s2 = {'a', 'b', 'c'}
s3 = {1, 'a', True}
s4 = set()
s5 = set('ABC')

print(s1)  # Output: {1, 2, 3}
print(s2)  # Output: {'a', 'b', 'c'}
print(s3)  # Output: {1, 'a'} (True is considered as 1)
print(s4)  # Output: set()
print(s5)  # Output: {'A', 'B', 'C'}
```

Sets always contain unique items—adding duplicate items is safe but pointless. For example, these three sets are the same:```set("apple")```, ```set("aple")```, and ```{'e', 'p', 'a', 'l'}```. In view of this, sets are often used to eliminate duplicates. For example, if x is a list of strings, after executing x = list(set(x)), all of x’s strings will be unique—and in an arbitrary order.

The standard set operators in Python (union, intersection, difference, and symmetric difference)

**Union**

The union operator ```|``` combines all unique elements from both sets.

```py
# Union
set1 = {'apple', 'banana', 'cherry'}
set2 = {'banana', 'date', 'fig'}
set3 = set("pecan")
set4 = set("pie")

# Union of words
union_set = set1 | set2
print(union_set == {'apple', 'banana', 'cherry', 'date', 'fig'})  # Output: True
print("Union of words:", union_set)  # Output: {'apple', 'banana', 'cherry', 'date', 'fig'}

# Union of characters
union_chars = set3 | set4
print(union_chars == {'p', 'e', 'c', 'a', 'n', 'i'})  # Output: True
print("Union of characters:", union_chars)  # Output: {'p', 'e', 'c', 'a', 'n', 'i'}
```

**Intersection**

The intersection operator ```&``` returns the common elements present in both sets.

```py
# Intersection
set1 = {'apple', 'banana', 'cherry'}
set2 = {'banana', 'date', 'fig'}
set3 = set("pecan")
set4 = set("pie")

# Intersection of words
intersection_set = set1 & set2
print(intersection_set == {'banana'})  # Output: True
print("Intersection of words:", intersection_set)  # Output: {'banana'}

# Intersection of characters
intersection_chars = set3 & set4
print(intersection_chars == {'p', 'e'})  # Output: True
print("Intersection of characters:", intersection_chars)  # Output: {'p', 'e'}
```

**Difference**

The difference operator ```-``` returns elements present in the first set but not in the second set.

```py
# Difference
set1 = {'apple', 'banana', 'cherry'}
set2 = {'banana', 'date', 'fig'}
set3 = set("pecan")
set4 = set("pie")

# Difference of words
difference_set = set1 - set2
print(difference_set == {'apple', 'cherry'})  # Output: True
print("Difference of words:", difference_set)  # Output: {'apple', 'cherry'}

# Difference of characters
difference_chars = set3 - set4
print(difference_chars == {'c', 'a', 'n'})  # Output: True
print("Difference of characters:", difference_chars)  # Output: {'c', 'a', 'n'}
```

**Symmetric Difference**

The symmetric difference operator ```^``` returns elements present in either of the sets but not in both.

```py
# Symmetric Difference
set1 = {'apple', 'banana', 'cherry'}
set2 = {'banana', 'date', 'fig'}
set3 = set("pecan")
set4 = set("pie")

# Symmetric Difference of words
sym_diff_set = set1 ^ set2
print(sym_diff_set == {'apple', 'cherry', 'date', 'fig'})  # Output: True
print("Symmetric Difference of words:", sym_diff_set)  # Output: {'apple', 'cherry', 'date', 'fig'}

# Symmetric Difference of characters
sym_diff_chars = set3 ^ set4
print(sym_diff_chars == {'c', 'a', 'n', 'i'})  # Output: True
print("Symmetric Difference of characters:", sym_diff_chars)  # Output: {'c', 'a', 'n', 'i'}
```

**Set Methods and Operators**

**s.add(x)**

Adds an element x to the set s.

```py
# Using add() method
s = {'apple', 'banana', 'cherry'}
s.add('date')
print(s)  # Output: {'apple', 'banana', 'cherry', 'date'}
```

**s.clear()**

Removes all elements from the set s, making it an empty set.

```py
# Using clear() method
s = {'apple', 'banana', 'cherry'}
s.clear()
print(s)  # Output: set()
```

**s.copy()**

Returns a shallow copy of the set s.

```py
# Using copy() method
s = {'apple', 'banana', 'cherry'}
s_copy = s.copy()
print(s_copy)  # Output: {'apple', 'banana', 'cherry'}
```

**s.difference(t) or s - t**

Returns a new set with elements in s that are not in set t.

```py
# Using difference() method
s = {'apple', 'banana', 'cherry'}
t = {'banana', 'date'}
difference = s.difference(t)
print(difference)  # Output: {'apple', 'cherry'}

# Using - operator
difference = s - t
print(difference)  # Output: {'apple', 'cherry'}
```

**s.difference_update(t) or s -= t**

Removes all elements of t from s.

```py
# Using difference_update() method
s = {'apple', 'banana', 'cherry'}
t = {'banana', 'date'}
s.difference_update(t)
print(s)  # Output: {'apple', 'cherry'}

# Using -= operator
s = {'apple', 'banana', 'cherry'}
s -= t
print(s)  # Output: {'apple', 'cherry'}
```

**s.discard(x)**

Removes element x from the set if it is a member. If x is not a member, do nothing.

```py
# Using discard() method
s = {'apple', 'banana', 'cherry'}
s.discard('banana')
print(s)  # Output: {'apple', 'cherry'}
s.discard('date')  # Does nothing since 'date' is not in the set
print(s)  # Output: {'apple', 'cherry'}
```

**s.intersection(t) or s & t**

Returns a new set with elements common to s and t.

```py
# Using intersection() method
s = {'apple', 'banana', 'cherry'}
t = {'banana', 'date'}
intersection = s.intersection(t)
print(intersection)  # Output: {'banana'}

# Using & operator
intersection = s & t
print(intersection)  # Output: {'banana'}
```

**s.intersection_update(t) or s &= t**

Updates the set s, keeping only elements found in it and t.

```py
# Using intersection_update() method
s = {'apple', 'banana', 'cherry'}
t = {'banana', 'date'}
s.intersection_update(t)
print(s)  # Output: {'banana'}

# Using &= operator
s = {'apple', 'banana', 'cherry'}
s &= t
print(s)  # Output: {'banana'}
```

**s.isdisjoint(t)**

Returns True if s has no elements in common with t.

```py
# Using isdisjoint() method
s = {'apple', 'banana', 'cherry'}
t = {'date', 'fig'}
print(s.isdisjoint(t))  # Output: True

t = {'banana', 'date'}
print(s.isdisjoint(t))  # Output: False
```

**s.issubset(t) or s <= t**

Returns True if all elements of s are in t.

```py
# Using issubset() method
s = {'apple', 'banana'}
t = {'apple', 'banana', 'cherry'}
print(s.issubset(t))  # Output: True

# Using <= operator
print(s <= t)  # Output: True
```

**s.issuperset(t) or s >= t**

Returns True if all elements of t are in s.

```py
# Using issuperset() method
s = {'apple', 'banana', 'cherry'}
t = {'banana', 'cherry'}
print(s.issuperset(t))  # Output: True

# Using >= operator
print(s >= t)  # Output: True
```

**s.pop()**

Removes and returns an arbitrary element from the set s. Raises KeyError if the set is empty.

```py
# Using pop() method
s = {'apple', 'banana', 'cherry'}
element = s.pop()
print(element)  # Output: 'apple' (or another element, since sets are unordered)
print(s)  # Output: {'banana', 'cherry'} (or the remaining elements)
```

**s.remove(x)**

Removes element x from the set s. Raises KeyError if x is not a member.

```py
# Using remove() method
s = {'apple', 'banana', 'cherry'}
s.remove('banana')
print(s)  # Output: {'apple', 'cherry'}
# s.remove('date')  # Raises KeyError
```

**s.symmetric_difference(t) or s ^ t**

Returns a new set with elements in either s or t but not in both.

```py
# Using symmetric_difference() method
s = {'apple', 'banana', 'cherry'}
t = {'banana', 'date'}
sym_diff = s.symmetric_difference(t)
print(sym_diff)  # Output: {'apple', 'cherry', 'date'}

# Using ^ operator
sym_diff = s ^ t
print(sym_diff)  # Output: {'apple', 'cherry', 'date'}
```

**s.symmetric_difference_update(t) or s ^= t**

Updates the set s to the symmetric difference of itself and t

```py
# Using symmetric_difference_update() method
s = {'apple', 'banana', 'cherry'}
t = {'banana', 'date'}
s.symmetric_difference_update(t)
print(s)  # Output: {'apple', 'cherry', 'date'}

# Using ^= operator
s = {'apple', 'banana', 'cherry'}
s ^= t
print(s)  # Output: {'apple', 'cherry', 'date'}
```

**s.union(t) or s | t**

Returns a new set with elements from both s and t.

```py
# Using union() method
s = {'apple', 'banana', 'cherry'}
t = {'banana', 'date'}
union_set = s.union(t)
print(union_set)  # Output: {'apple', 'banana', 'cherry', 'date'}

# Using | operator
union_set = s | t
print(union_set)  # Output: {'apple', 'banana', 'cherry', 'date'}
```

**s.update(t) or s |= t**

Updates the set s with elements from t.

```py
# Using update() method
s = {'apple', 'banana', 'cherry'}
t = {'banana', 'date'}
s.update(t)
print(s)  # Output: {'apple', 'banana', 'cherry', 'date'}

# Using |= operator
s = {'apple', 'banana', 'cherry'}
s |= t
print(s)  # Output: {'apple', 'banana', 'cherry', 'date'}
```

Sets are compared using the standard comparison operators (<, <=, ==, !=, >=, >), which compare based on subset and superset relationships.

```py
set1 = {1, 2, 3}
set2 = {1, 2, 3, 4}

print(set1 < set2)   # Output: True (set1 is a proper subset of set2)
print(set1 <= set2)  # Output: True (set1 is a subset of set2)
print(set1 == set2)  # Output: False (set1 is not equal to set2)
print(set1 != set2)  # Output: True (set1 is not equal to set2)
print(set1 >= set2)  # Output: False (set1 is not a superset of set2)
print(set1 > set2)   # Output: False (set1 is not a proper superset of set2)
```

**Iterating Over Items in a Set**

Basic Iteration: To iterate over each element in a set, we use a for loop:

```py
# Basic Iteration
my_set = {1, 2, 3, 4, 5}

for item in my_set:
    print(item)
# Output:
# 1
# 2
# 3
# 4
# 5
```

Using Set Comprehensions: Set comprehensions provide a concise way to iterate over sets and perform operations on their elements:

```py
# Using Set Comprehensions
my_set = {1, 2, 3, 4, 5}
squared_set = {item ** 2 for item in my_set}
print(squared_set)
# Output: {1, 4, 9, 16, 25}
```

Using the map Function: The map function applies a specified function to each item in the set (though it returns a map object, not a set):

```py
# Using the map Function
my_set = {1, 2, 3, 4, 5}
squared_set = set(map(lambda x: x ** 2, my_set))
print(squared_set)
# Output: {1, 4, 9, 16, 25}
```

Using the filter Function: The filter function creates a set of elements for which a specified function returns True:

```py
# Using the filter Function
my_set = {1, 2, 3, 4, 5}
even_set = set(filter(lambda x: x % 2 == 0, my_set))
print(even_set)
# Output: {2, 4}
```

**Some practical use cases of sets**

  - **Removing Duplicates from a List**

```py
# Removing duplicates from a list using a set
numbers = [1, 2, 2, 3, 4, 4, 5]
unique_numbers = list(set(numbers))
print(unique_numbers)  # Output: [1, 2, 3, 4, 5]
```

  - **Membership Testing**

```py
# Checking membership in a set
fruits = {'apple', 'banana', 'cherry'}
print('banana' in fruits)  # Output: True
print('date' in fruits)    # Output: False
```



###### <a name="chapter3part2.2"></a>Chapter 3 - Part 2.2: Set Comprehensions

In addition to creating sets by calling set(), or by using a set literal,we can also create sets using set comprehensions.A set comprehension is an expression and a loop with an optional condition enclosed in braces. Like list comprehensions, two syntaxes are supported:

```
{expression for item in iterable}
{expression for item in iterable if condition}
```

We can use these to achieve a filtering effect



```py
html = {x for x in files if x.lower().endswith((".htm", ".html"))}
```

Given a list of filenames in files, this set comprehension makes the set html hold only those filenames that end in .htm or .html, regardless of case.

###### <a name="chapter3part2.3"></a>Chapter 3 - Part 2.3: Frozen Sets

A frozenset is an immutable version of a set in Python. Unlike sets, frozen sets cannot be modified after they are created. This immutability makes them hashable, meaning they can be used as keys in dictionaries or elements of other sets.

- **Immutable**: Once created, elements cannot be added or removed.
- **Hashable**: Can be used as keys in dictionaries.
- **Supports Standard Set Operations**: Union, intersection, difference, and symmetric difference.

**Creation**

```py
# Creating a frozenset
frozen_set1 = frozenset([1, 2, 3, 4])
print(frozen_set1)  # Output: frozenset({1, 2, 3, 4})

# Creating from a set
set1 = {5, 6, 7, 8}
frozen_set2 = frozenset(set1)
print(frozen_set2)  # Output: frozenset({8, 5, 6, 7})
```

**Using Frozen Sets in Dictionaries**

```py
# Using a frozenset as a dictionary key
d = {}
frozen_set_key = frozenset([1, 2, 3])
d[frozen_set_key] = "value"
print(d)  # Output: {frozenset({1, 2, 3}): 'value'}
```

**Set Operations**

- **Union**

```py
# Union of frozensets
frozen_set1 = frozenset([1, 2, 3])
frozen_set2 = frozenset([3, 4, 5])
result = frozen_set1 | frozen_set2
print(result)  # Output: frozenset({1, 2, 3, 4, 5})
```

- **Intersection**

```py
# Intersection of frozensets
result = frozen_set1 & frozen_set2
print(result)  # Output: frozenset({3})
```

- **Difference**

```py
# Difference of frozensets
result = frozen_set1 - frozen_set2
print(result)  # Output: frozenset({1, 2})
```

- **Symmetric Difference**

```py
# Symmetric difference of frozensets
result = frozen_set1 ^ frozen_set2
print(result)  # Output: frozenset({1, 2, 4, 5})
```

**Practical Use Cases for Frozen Sets**

- **Using as Dictionary Keys:**

```py
permissions = {
    frozenset(["read", "write"]): "Admin",
    frozenset(["read"]): "User"
}

user_permissions = frozenset(["read"])
print(permissions[user_permissions])  # Output: User
```

- **Ensuring Unchangeable Groupings**

```py
valid_options = frozenset(["option1", "option2", "option3"])

if user_choice in valid_options:
    print("Valid choice")
else:
    print("Invalid choice")
```

- **Set Operations on Immutable Data**

```py
# Example with configuration settings
default_settings = frozenset(["setting1", "setting2", "setting3"])
user_settings = frozenset(["setting2", "setting4"])

# Combining settings without modifying the originals
combined_settings = default_settings | user_settings
print(combined_settings)  # Output: frozenset({'setting1', 'setting2', 'setting3', 'setting4'})
```

#### <a name="chapter3part3"></a>Chapter 3 - Part 3: Mapping Types

A mapping type is one that supports the membership operator ```(in)``` and the size function ```(len())```, and is iterable.

Mappings are collections of key–value items and provide methods for accessing items and their keys and values.

When iterated, unordered mapping types provide their items in an arbitrary order.

Python 3.0 provides two unordered mapping types, the built-in ```dict``` type and the standard library’s ```collections.defaultdict``` type.

A new, ordered mapping type, ```collections.OrderedDict```, was introduced with Python 3.1; this is a dictionary that has the same methods and properties (i.e., the same API) as the built-in dict, but stores its items in insertion order.

Only hashable objectsmay be used as dictionary keys, so immutable data types such as ```float```, ```frozenset```, ```int```, ```str```, and ```tuple``` can be used as dictionary keys, but mutable types such as ```dict```, ```list```, and ```set``` cannot. On the other hand, each key’s associated value can be an object reference referring to an object of any type, including numbers, strings, lists, sets, dictionaries, functions, and so on.

###### <a name="chapter3part3.1"></a>Chapter 3 - Part 3.1: Dictionaries

A ```dict``` is an unordered collection of zero or more key–value pairs whose keys are object references that refer to hashable objects,and whose values are object references referring to objects of any type. Dictionaries are mutable, so we can easily add or remove items, but since they are unordered they have no notion of index position and so cannot be sliced or strided.

**Key Properties**

  - **Keys**: Must be immutable and unique within a dictionary. Common key types include strings, numbers, and tuples.
    
  - **Values**: Can be of any data type and are associated with a specific key.

Here are a few examples demonstrating different ways to create and use dictionaries:

```py
# Creating dictionaries
d1 = {'a': 1, 'b': 2, 'c': 3}
d2 = dict(a=1, b=2, c=3)
d3 = dict([('a', 1), ('b', 2), ('c', 3)])
d4 = dict.fromkeys(['x', 'y', 'z'], 0)

print(d1)  # Output: {'a': 1, 'b': 2, 'c': 3}
print(d2)  # Output: {'a': 1, 'b': 2, 'c': 3}
print(d3)  # Output: {'a': 1, 'b': 2, 'c': 3}
print(d4)  # Output: {'x': 0, 'y': 0, 'z': 0}
```

```py
# Different ways to create the same dictionary

# Using a dictionary literal
d1 = {"id": 1948, "name": "Washer", "size": 3}

# Using the dict constructor with keyword arguments
d2 = dict(id=1948, name="Washer", size=3)

# Using the dict constructor with a list of tuples
d3 = dict([("id", 1948), ("name", "Washer"), ("size", 3)])

# Using the dict constructor with zip() to combine keys and values
d4 = dict(zip(("id", "name", "size"), (1948, "Washer", 3)))

# All methods produce the same dictionary
print(d1)  # Output: {'id': 1948, 'name': 'Washer', 'size': 3}
print(d2)  # Output: {'id': 1948, 'name': 'Washer', 'size': 3}
print(d3)  # Output: {'id': 1948, 'name': 'Washer', 'size': 3}
print(d4)  # Output: {'id': 1948, 'name': 'Washer', 'size': 3}
```

The built-in ```zip()``` function that is used to create dictionary d4 returns a list of tuples, the first of which has the first items of each of the ```zip()``` function’s iterable arguments,the second of which has the second items, and so on. The keyword argument syntax (used to create dictionary d2) is usually the most compact and convenient, providing the keys are valid identifiers.

A dictionary in Python is an unordered collection of key-value pairs, where each key is unique. Keys must be immutable types (such as strings, numbers, or tuples), while values can be of any type.

```py
d = {"root": 18, "blue": [75, "R", 2], 21: "venus", -14: None, "mars": "rover", (4, 11): 18, 0: 45}
```

**Accessing Values**

You can access values in a dictionary using square brackets [] with the key:

```py
# Access values
print(d["root"])  # Output: 18
print(d[21])      # Output: 'venus'
```

If you try to access a key that does not exist, Python raises a KeyError:

```py
# Accessing a non-existent key
# print(d[91])  # Raises KeyError
```

**Adding or Updating Items**

```py
# Adding a new key-value pair
d["X"] = 59
print(d)  # Output: {'root': 18, 'blue': [75, 'R', 2], 21: 'venus', -14: None, 'mars': 'rover', (4, 11): 18, 0: 45, 'X': 59}

# Updating an existing key’s value
d["root"] = 20
print(d)  # Output: {'root': 20, 'blue': [75, 'R', 2], 21: 'venus', -14: None, 'mars': 'rover', (4, 11): 18, 0: 45, 'X': 59}
```

**Deleting Items**

To remove an item from a dictionary, use the del statement. If the key does not exist, Python raises a KeyError:

```py
# Deleting an item
del d["mars"]
print(d)  # Output: {'root': 20, 'blue': [75, 'R', 2], 21: 'venus', -14: None, (4, 11): 18, 0: 45, 'X': 59}

# Attempting to delete a non-existent key
# del d["nonexistent"]  # Raises KeyError
```

**Dictionary Methods**

- **d.clear()**
  
Removes all items from the dictionary, making it an empty dictionary.

```py
d = {"a": 1, "b": 2, "c": 3}
d.clear()
print(d)  # Output: {}
```

- **d.copy()**

Returns a shallow copy of the dictionary. Changes to the copy do not affect the original dictionary, and vice versa.

```py
d = {"a": 1, "b": 2, "c": 3}
d_copy = d.copy()
print(d_copy)  # Output: {'a': 1, 'b': 2, 'c': 3}
```

- **d.fromkeys(s, v)**

Creates a new dictionary with keys from sequence s and values set to v. If v is not provided, the default value is None.

```py
keys = ['a', 'b', 'c']
default_value = 0
d = dict.fromkeys(keys, default_value)
print(d)  # Output: {'a': 0, 'b': 0, 'c': 0}

d_default = dict.fromkeys(keys)
print(d_default)  # Output: {'a': None, 'b': None, 'c': None}
```

- **d.get(k)**

Returns the value for the key k. If the key is not found, it returns None.

```py
d = {"a": 1, "b": 2}
value = d.get("a")
print(value)  # Output: 1

value_not_found = d.get("c")
print(value_not_found)  # Output: None
```

- **d.get(k, v)**

Returns the value for the key k. If the key is not found, it returns the default value v.

```py
d = {"a": 1, "b": 2}
value = d.get("a", 0)
print(value)  # Output: 1

value_default = d.get("c", 0)
print(value_default)  # Output: 0
```

- **d.items()**

Returns a view object that displays a list of a dictionary’s key-value tuple pairs

```py
d = {"a": 1, "b": 2, "c": 3}
items = d.items()
print(items)  # Output: dict_items([('a', 1), ('b', 2), ('c', 3)])
```

- **d.keys()**

Returns a view object that displays a list of all the keys in the dictionary.

```py
d = {"a": 1, "b": 2, "c": 3}
keys = d.keys()
print(keys)  # Output: dict_keys(['a', 'b', 'c'])
```

- **d.pop(k)**

Removes the item with the key k and returns its value. Raises a KeyError if the key is not found.

```py
d = {"a": 1, "b": 2, "c": 3}
value = d.pop("b")
print(value)  # Output: 2
print(d)  # Output: {'a': 1, 'c': 3}

# d.pop("x")  # Raises KeyError if key "x" is not in the dictionary
```

- **d.pop(k, v)**

Removes the item with the key k and returns its value. If the key is not found, returns the default value v.

```py
d = {"a": 1, "b": 2}
value = d.pop("b", 0)
print(value)  # Output: 2

value_default = d.pop("c", 0)
print(value_default)  # Output: 0
```

- **d.popitem()**

Removes and returns an arbitrary (key, value) pair from the dictionary. Raises a KeyError if the dictionary is empty.

```py
d = {"a": 1, "b": 2, "c": 3}
item = d.popitem()
print(item)  # Output: ('c', 3) (or another item, since it's arbitrary)
print(d)  # Output: {'a': 1, 'b': 2}
```

- **d.setdefault(k, v)**

Returns the value for the key k. If the key is not found, inserts the key with the value v and returns v.

```py
d = {"a": 1, "b": 2}
value = d.setdefault("b", 0)
print(value)  # Output: 2

new_value = d.setdefault("c", 3)
print(new_value)  # Output: 3
print(d)  # Output: {'a': 1, 'b': 2, 'c': 3}
```

- **d.update(a)**

Updates the dictionary with elements from another dictionary or from an iterable of key-value pairs. If a key already exists, its value is updated with the new value.

```py
d = {"a": 1, "b": 2}
d.update({"b": 3, "c": 4})
print(d)  # Output: {'a': 1, 'b': 3, 'c': 4}

d.update([("d", 5), ("e", 6)])
print(d)  # Output: {'a': 1, 'b': 3, 'c': 4, 'd': 5, 'e': 6}
```

- **d.values()**

Returns a view object that displays a list of all the values in the dictionary.

```py
d = {"a": 1, "b": 2, "c": 3}
values = d.values()
print(values)  # Output: dict_values([1, 2, 3])
```

In Python, dictionary view objects, such as those returned by methods like dict.keys(), dict.values(), and dict.items(), support some set-like operations. This allows for efficient operations on the keys, values, or key-value pairs of dictionaries. Here’s a detailed overview of these operations

**Intersection (&)**

Returns a new view with elements that are common to both views.

```py
d1 = {"a": 1, "b": 2, "c": 3}
d2 = {"b": 4, "c": 5, "d": 6}

keys1 = d1.keys()  # dict_keys(['a', 'b', 'c'])
keys2 = d2.keys()  # dict_keys(['b', 'c', 'd'])
common_keys = keys1 & keys2
print(common_keys)  # Output: {'b', 'c'}

values1 = d1.values()  # dict_values([1, 2, 3])
values2 = d2.values()  # dict_values([4, 5, 6])
common_values = set(values1) & set(values2)
print(common_values)  # Output: set() (no common values)
```

**Union (|)**

Returns a new view with all unique elements from both views.

```py
d1 = {"a": 1, "b": 2, "c": 3}
d2 = {"b": 4, "c": 5, "d": 6}

keys1 = d1.keys()  # dict_keys(['a', 'b', 'c'])
keys2 = d2.keys()  # dict_keys(['b', 'c', 'd'])
all_keys = keys1 | keys2
print(all_keys)  # Output: {'a', 'b', 'c', 'd'}

values1 = d1.values()  # dict_values([1, 2, 3])
values2 = d2.values()  # dict_values([4, 5, 6])
all_values = set(values1) | set(values2)
print(all_values)  # Output: {1, 2, 3, 4, 5, 6}
```

**Difference (-)**

Returns a new view with elements present in the first view but not in the second view.

```py
d1 = {"a": 1, "b": 2, "c": 3}
d2 = {"b": 4, "c": 5, "d": 6}

keys1 = d1.keys()  # dict_keys(['a', 'b', 'c'])
keys2 = d2.keys()  # dict_keys(['b', 'c', 'd'])
unique_keys = keys1 - keys2
print(unique_keys)  # Output: {'a'}

values1 = d1.values()  # dict_values([1, 2, 3])
values2 = d2.values()  # dict_values([4, 5, 6])
unique_values = set(values1) - set(values2)
print(unique_values)  # Output: {1, 2, 3}
```

**Symmetric Difference**

Returns a new view with elements in either the first or second view but not in both.

```py
d1 = {"a": 1, "b": 2, "c": 3}
d2 = {"b": 4, "c": 5, "d": 6}

keys1 = d1.keys()  # dict_keys(['a', 'b', 'c'])
keys2 = d2.keys()  # dict_keys(['b', 'c', 'd'])
sym_diff_keys = keys1 ^ keys2
print(sym_diff_keys)  # Output: {'a', 'd'}

values1 = d1.values()  # dict_values([1, 2, 3])
values2 = d2.values()  # dict_values([4, 5, 6])
sym_diff_values = set(values1) ^ set(values2)
print(sym_diff_values)  # Output: {1, 2, 3, 4, 5, 6}
```

**Iterating Over Dictionary**

Use loops to iterate over dictionary keys, values, or key-value pairs.

**Basic Iteration**

  - **Iterating over Keys**

```py
# Iterating over dictionary keys
d = {"a": 1, "b": 2, "c": 3}

for key in d:
    print(key)
# Output:
# a
# b
# c
```

  - **Iterating over Values**

```py
# Iterating over dictionary values
d = {"a": 1, "b": 2, "c": 3}

for value in d.values():
    print(value)
# Output:
# 1
# 2
# 3
```

  - **Iterating over Key-Value Pairs**

```py
# Iterating over dictionary key-value pairs
d = {"a": 1, "b": 2, "c": 3}

for key, value in d.items():
    print(f"Key: {key}, Value: {value}")
# Output:
# Key: a, Value: 1
# Key: b, Value: 2
# Key: c, Value: 3
```

**Dictionary Comprehensions**

Create new dictionaries or filter existing ones using concise syntax.

  - **Creating a New Dictionary from an Existing One**

```py
# Dictionary comprehension to create a new dictionary with values doubled
d = {"a": 1, "b": 2, "c": 3}
new_d = {key: value * 2 for key, value in d.items()}
print(new_d)
# Output: {'a': 2, 'b': 4, 'c': 6}
```

  - **Filtering Dictionary Items**

```py
# Dictionary comprehension to filter out items with value less than 3
d = {"a": 1, "b": 2, "c": 3}
filtered_d = {key: value for key, value in d.items() if value >= 3}
print(filtered_d)
# Output: {'c': 3}
```

**Using the map Function**

The map function applies a specified function to each item in an iterable and returns a map object.

  - **Applying a Function to Values**

```py
# Using map to apply a function to dictionary values
d = {"a": 1, "b": 2, "c": 3}

def double(x):
    return x * 2

mapped_values = map(double, d.values())
print(list(mapped_values))
# Output: [2, 4, 6]
```

  - **Creating a New Dictionary Using map**

```py
# Creating a new dictionary with keys unchanged and values doubled using map
d = {"a": 1, "b": 2, "c": 3}

keys = d.keys()
values = map(double, d.values())
new_d = dict(zip(keys, values))
print(new_d)
# Output: {'a': 2, 'b': 4, 'c': 6}
```

**Using the filter Function**

The filter function applies a specified function to each item in an iterable and returns only those items where the function returns True.

  - **Filtering Keys or Values**

```py
# Filtering dictionary items based on a condition
d = {"a": 1, "b": 2, "c": 3}

def is_even(x):
    return x % 2 == 0

# Filter dictionary values that are even
filtered_values = filter(is_even, d.values())
print(list(filtered_values))
# Output: [2]

# Creating a new dictionary with only even values
filtered_d = {key: value for key, value in d.items() if is_even(value)}
print(filtered_d)
# Output: {'b': 2}
```

  - **Filtering Items with Custom Condition**

```py
# Filtering items with custom condition on both keys and values
d = {"apple": 1, "banana": 2, "cherry": 3}

def key_starts_with_b(key):
    return key.startswith('b')

# Creating a new dictionary with keys that start with 'b'
filtered_d = {key: value for key, value in d.items() if key_starts_with_b(key)}
print(filtered_d)
# Output: {'banana': 2}
```

**Common use cases of Dictionaries**

  - **Counting Occurrences**

Dictionaries are often used to count occurrences of items, such as counting the frequency of words in a text.

```py
# Counting word frequencies in a text
text = "apple banana apple orange banana apple"
word_counts = {}

for word in text.split():
    if word in word_counts:
        word_counts[word] += 1
    else:
        word_counts[word] = 1

print(word_counts)
# Output: {'apple': 3, 'banana': 2, 'orange': 1}
```

  - **Storing Configuration Settings**

Dictionaries can store configuration settings or parameters for applications, making it easy to access and update these settings.

```py
# Configuration settings for a web application
config = {
    "host": "localhost",
    "port": 8080,
    "debug": True,
    "database": {
        "name": "app_db",
        "user": "admin",
        "password": "secure_password"
    }
}

print(config["host"])  # Output: localhost
print(config["database"]["name"])  # Output: app_db
```

  - **Caching Results**

Dictionaries can be used to implement caching mechanisms to store and retrieve previously computed results efficiently.

```py
# Caching results of expensive computation
cache = {}

def expensive_computation(x):
    if x in cache:
        return cache[x]
    
    result = x * x  # Placeholder for an expensive computation
    cache[x] = result
    return result

print(expensive_computation(10))  # Output: 100
print(expensive_computation(10))  # Output: 100 (from cache)
```

  - **Grouping Data**

Dictionaries can group related data together, such as organizing employee information by department.

```py
# Grouping employees by department
employees = {
    "HR": ["Alice", "Bob"],
    "Engineering": ["Charlie", "Diana"],
    "Sales": ["Eve", "Frank"]
}

print(employees["Engineering"])  # Output: ['Charlie', 'Diana']
```

  - **Handling JSON Data**

Dictionaries are often used to handle JSON data, as JSON objects map directly to Python dictionaries.

```py
import json

# JSON data as a string
json_data = '{"name": "Alice", "age": 30, "city": "New York"}'

# Convert JSON string to dictionary
data = json.loads(json_data)

print(data["name"])  # Output: Alice
```



###### <a name="chapter3part3.2"></a>Chapter 3 - Part 3.2: Dictionary Comprehensions

A dictionary comprehension is an expression and a loop with an optional condition enclosed in braces, very similar to a set comprehension. Like list and set comprehensions, two syntaxes are supported:

```
{keyexpression: valueexpression for key, value in iterable}
{keyexpression: valueexpression for key, value in iterable if condition}
```

Here is how we could use a dictionary comprehension to create a dictionary where each key is the name of a file in the current directory and each value is the size of the file in bytes

```py
file_sizes = {name: os.path.getsize(name) for name in os.listdir(".")}
```

A dictionary comprehension can also be used to create an inverted dictionary. For example, given dictionary d, we can produce a new dictionary whose keys are d’s values and whose values are d’s keys:

```py
inverted_d = {v: k for k, v in d.items()}
```

###### <a name="chapter3part3.3"></a>Chapter 3 - Part 3.3: Default Dictionaries

In Python, the collections module provides a defaultdict class which extends the built-in dict class by allowing you to set default values for missing keys. This can simplify many common dictionary operations where you need to handle missing keys gracefully.

**Overview of defaultdict**

Purpose: defaultdict helps avoid key errors and simplifies code by providing a default value for missing keys.

Initialization: You initialize a defaultdict with a factory function that defines the default value for new keys.

**Key Features**

Automatic Default Values: When you access or modify a key that does not exist, defaultdict automatically creates a new entry with a default value specified by the factory function.

Factory Functions: The factory function can be any callable object, such as list, int, or set, which determines the default value type.

Here's a general example using defaultdict:

```py
from collections import defaultdict

# Using int as the default factory, which initializes missing keys with 0
dd = defaultdict(int)

dd['a'] += 1
dd['b'] += 2

print(dd['a'])  # Output: 1
print(dd['b'])  # Output: 2
print(dd['c'])  # Output: 0 (default value for missing keys)
```

###### <a name="chapter3part3.4"></a>Chapter 3 - Part 3.4: Ordered Dictionaries

In Python, dictionaries from version 3.7 onwards maintain insertion order as part of the language specification. However, before Python 3.7, this was not guaranteed, and collections.OrderedDict was used to explicitly maintain the order of items in a dictionary.

**Overview of OrderedDict**

- **Purpose**: OrderedDict is a dictionary subclass that maintains the order of keys as they are added. It was primarily useful in Python versions prior to 3.7, but remains useful for additional methods and functionalities it provides.

- **Initialization**: You initialize OrderedDict just like a regular dictionary, but it preserves the order of key-value pairs.

**Key Features**

- Order Preservation: OrderedDict keeps track of the order in which items are inserted. This makes it easy to iterate over the dictionary in the same order.

- Reordering: OrderedDict provides additional methods to rearrange the order of keys.

- Move Operations: Methods to move keys around within the dictionary.

```py
from collections import OrderedDict

# Create an OrderedDict
od = OrderedDict([('a', 1), ('b', 2), ('c', 3)])

# Print the OrderedDict
print(od)
# Output: OrderedDict([('a', 1), ('b', 2), ('c', 3)])

# Iterate over OrderedDict
for key, value in od.items():
    print(f"{key}: {value}")

# Output:
# a: 1
# b: 2
# c: 3
```

#### <a name="chapter3part4"></a>Chapter 3 - Part 4: Iterating and Copying Collections

###### <a name="chapter3part4.1"></a>Chapter 3 - Part 4.1: Iterators and Iterable Operations and Functions

An iterable data type is one that can return each of its items one at a time.

- ```Iterable```: An object is considered iterable if it implements the ```__iter__()``` method, which returns an iterator. This is a common way for objects to be iterated over in a loop or with functions like ```map()```, ```filter()```, etc.

- ```Iterator```: An iterator is an object that represents a stream of data. It has two main methods:
  - ```__iter__()```: This method returns the iterator object itself. This is used in case an iterable is required to return an iterator.
  - ```__next__()```: This method returns the next item in the stream. When there are no more items to return, it raises a StopIteration exception to signal that the iteration is complete.
 
- ```Sequence```: Sequences are a specific type of iterable that can be indexed. They implement the ```__getitem__()``` method, which allows for accessing elements using integer indices starting from 0. Common sequence types in Python include lists, tuples, and strings.

**Common Iterable Operators and Functions**

  - **s + t**

Concatenates two sequences (s and t) if they are of the same type (e.g., two lists, two tuples, or two strings)

```py
s = [1, 2, 3]
t = [4, 5, 6]
print(s + t)  # Output: [1, 2, 3, 4, 5, 6]

s = "Hello, "
t = "world!"
print(s + t)  # Output: "Hello, world!" 
```

  - **s * n**

Repeats the sequence s n times.

```py
s = [1, 2, 3]
print(s * 3)  # Output: [1, 2, 3, 1, 2, 3, 1, 2, 3]

s = "Hi!"
print(s * 4)  # Output: "Hi!Hi!Hi!Hi!"
```

  - **x in i**

Checks if the element x is present in the iterable i. Returns True if x is in i, otherwise False.

```py
s = [1, 2, 3, 4, 5]
print(3 in s)  # Output: True
print(6 in s)  # Output: False

s = "Python"
print('P' in s)  # Output: True
print('p' in s)  # Output: False 
```

  - **all(i)**

Returns True if all elements of the iterable i are true (or if the iterable is empty). If any element is false, it returns False.

```py
print(all([True, True, True]))  # Output: True
print(all([True, False, True])) # Output: False
print(all([]))                  # Output: True (an empty iterable is considered "all true")
```

  - **any(i)**

Returns True if any element of the iterable i is true. If all elements are false or if the iterable is empty, it returns False.

```py
print(any([False, False, True]))  # Output: True
print(any([False, False, False])) # Output: False
print(any([]))                    # Output: False (an empty iterable has no true elements)
```

  - **enumerate(i,start)**

Returns an iterator that produces pairs of an index and an element from the iterable i, starting at the start index (default is 0).

```py
for index, value in enumerate(['a', 'b', 'c'], start=1):
    print(index, value)
# Output:
# 1 a
# 2 b
# 3 c
```

  - **len(x)**

Returns the number of items in the iterable x.

```py
print(len([1, 2, 3, 4]))    # Output: 4
print(len("Hello"))         # Output: 5
print(len((1, 2, 3)))       # Output: 3 
```
  - **max(i, key)**

Returns the largest item in the iterable i. The key parameter is an optional function that computes a value for comparison.

```py
print(max([1, 2, 3, 4, 5]))              # Output: 5
print(max("apple", key=len))              # Output: "apple"

# Using a key function
print(max(['apple', 'banana', 'cherry'], key=lambda x: len(x)))  # Output: 'banana'
```

  - **min(i, key)**

Returns the smallest item in the iterable i. The key parameter is an optional function that computes a value for comparison.

```py
print(min([1, 2, 3, 4, 5]))              # Output: 1
print(min("apple", key=len))              # Output: "apple"

# Using a key function
print(min(['apple', 'banana', 'cherry'], key=lambda x: len(x)))  # Output: 'apple'
```

  - **range(start,stop,step)**

Returns an iterator that generates numbers from start to stop (exclusive) with a step size of step. The default values are start=0, stop=0, and step=1.

```py
print(list(range(5)))         # Output: [0, 1, 2, 3, 4]
print(list(range(2, 10, 2)))  # Output: [2, 4, 6, 8]
print(list(range(10, 0, -1))) # Output: [10, 9, 8, 7, 6, 5, 4, 3, 2, 1]
```

  - **reversed(i)**

Returns an iterator that accesses the elements of i in reverse order.

```py
print(list(reversed([1, 2, 3, 4, 5])))  # Output: [5, 4, 3, 2, 1]
print(list(reversed("Python")))         # Output: ['n', 'o', 'h', 't', 'y', 'P']
```

  - **sorted(i, key, reverse)**

Returns a new sorted list from the items in the iterable i. The key parameter is a function that extracts a comparison key from each element, and reverse is a boolean that, if True, sorts in descending order.

```py
print(sorted([5, 2, 9, 1, 5, 6]))       # Output: [1, 2, 5, 5, 6, 9]
print(sorted("python"))                 # Output: ['h', 'n', 'o', 'p', 't', 'y']

# Using key and reverse
print(sorted(['apple', 'banana', 'cherry'], key=len, reverse=True))  # Output: ['banana', 'cherry', 'apple']
```

  - **sum(i,start)**

Returns the sum of the elements in the iterable i, optionally starting from the value start.

```py
print(sum([1, 2, 3, 4, 5]))      # Output: 15
print(sum([1, 2, 3], start=10))  # Output: 16  
```
  - **zip(i1,..., iN)**

Returns an iterator of tuples, where the i-th tuple contains the i-th element from each of the input iterables. The iteration stops when the shortest input iterable is exhausted.

```py
 names = ['Alice', 'Bob', 'Charlie']
scores = [85, 90, 88]
print(list(zip(names, scores)))  # Output: [('Alice', 85), ('Bob', 90), ('Charlie', 88)]   
```

###### <a name="chapter3part4.2"></a>Chapter 3 - Part 4.2: Copying Collections

Since Python uses object references, when we use the assignment operator (=), Object no copying takes place. If the right-hand operand is a literal such as a string or a number, the left-hand operand is set to be an object reference that refers to the in-memory object that holds the literal’s value. If the right-hand operand is an object reference, the left-hand operand is set to be an object reference that refers to the same object as the right-hand operand.

When we assign large collections, such as long lists, the savings are very apparent.

```py
songs = ["Because", "Boys", "Carol"]
beatles = songs
print(beatles, songs) # Output: (['Because', 'Boys', 'Carol'], ['Because', 'Boys', 'Carol'])
```

Since lists are mutable, we can apply a change

```py
beatles[2] = "Cayenne"
beatles = songs
print(beatles, songs) # Output: (['Because', 'Boys', 'Cayenne'], ['Because', 'Boys', 'Cayenne'])
```

We applied the change using the beatles variable—but this is an object reference referring to the same list as songs refers to.

However, in some situations,we really dowant a separate copy of the collection (or other mutable object).

Many built-in collection types have a copy() method that creates a shallow copy of the collection.

**Lists:**

```py
original_list = [1, 2, 3, 4]
copied_list = original_list.copy()
print(copied_list)  # Output: [1, 2, 3, 4]
```

**Dictionaries**

```py
original_dict = {'a': 1, 'b': 2}
copied_dict = original_dict.copy()
print(copied_dict)  # Output: {'a': 1, 'b': 2}
```

**Sets**

```py
original_set = {1, 2, 3}
copied_set = original_set.copy()
print(copied_set)  # Output: {1, 2, 3}
```

**Using List Comprehensions**

You can use list comprehensions to create a new list that copies elements from an existing list.

```py
original_list = [1, 2, 3, 4]
copied_list = [item for item in original_list]
print(copied_list)  # Output: [1, 2, 3, 4]
```

**Using list() Constructor**

```py
original_list = [1, 2, 3, 4]
copied_list = list(original_list)
print(copied_list)  # Output: [1, 2, 3, 4]
```

**Using dict() Constructor**

```py
original_dict = {'a': 1, 'b': 2}
copied_dict = dict(original_dict)
print(copied_dict)  # Output: {'a': 1, 'b': 2}
```

**Using set() Constructor**

```py
original_set = {1, 2, 3}
copied_set = set(original_set)
print(copied_set)  # Output: {1, 2, 3}
```

**Using copy Module**

- Shallow Copy (copy.copy()):

A shallow copy creates a new object but does not create copies of nested objects. Instead, it inserts references to the objects found in the original.

```py
import copy

original_list = [1, [2, 3]]
shallow_copied_list = copy.copy(original_list)
print(shallow_copied_list)  # Output: [1, [2, 3]]
```

- Deep Copy (copy.deepcopy())

A deep copy creates a new object and recursively copies all objects found in the original. This means that nested objects are also copied.

```py
import copy

original_list = [1, [2, 3]]
deep_copied_list = copy.deepcopy(original_list)
print(deep_copied_list)  # Output: [1, [2, 3]]
```

**Using Slicing**

- For lists, you can use slicing to create a shallow copy.

```py
original_list = [1, 2, 3, 4]
copied_list = original_list[:]
print(copied_list)  # Output: [1, 2, 3, 4]
```

**When to Use Shallow vs. Deep Copy**

- **Shallow Copy**: Use when you only need a copy of the top-level structure, and you are okay with shared references for nested objects.

- **Deep Copy**: Use when you need a complete, independent copy of the entire structure, including nested objects.

```py
import copy

original_list = [1, [2, 3]]

# Shallow copy
shallow_copied_list = copy.copy(original_list)
shallow_copied_list[1][0] = 99
print(original_list)  # Output: [1, [99, 3]]
print(shallow_copied_list)  # Output: [1, [99, 3]]

# Deep copy
deep_copied_list = copy.deepcopy(original_list)
deep_copied_list[1][0] = 77
print(original_list)  # Output: [1, [99, 3]]
print(deep_copied_list)  # Output: [1, [77, 3]]
```

## <a name="chapter4"></a>Chapter 4: Control Structures and Functions

#### <a name="chapter4part1"></a>Chapter 4 - Part 1: Control Structures

Python provides conditional branching with ```if``` statements and looping with ```while``` and ```for …in``` statements. Python also has a ```conditional expression```—this is a kind of ```if``` statement that is Python’s answer to the ternary operator ```(?:)``` used in C-style languages.

###### <a name="chapter4part1.1"></a>Chapter 4 - Part 1.1: Conditional Branching

the general syntax for Python’s conditional branch statement:

```
if boolean_expression1:
  suite1
elif boolean_expression2:
  suite2
...
elif boolean_expressionN:
  suiteN
else:
  else_suite
```

The final ```else``` clause is optional.

If we want to account for a particular case, but want to do nothing if it occurs, we can use ```pass``` (which serves as a “do nothing” place holder) as that branch’s suite.

```py
x = 10

if x > 5:
    pass  # Do nothing if x is greater than 5
else:
    print("x is 5 or less")
```

Python also supports a shorthand for if-else statements called the ternary conditional operator, which is used for simple conditions.

```
expression1 if boolean_expression else expression2
```

```py
x = 10
result = "greater than 5" if x > 5 else "5 or less"
print(result) # Output: greater than 5
```

Ternary conditional operator (or inline if-else) can be use to set the value of a variable based on a condition

```py
# Define membership status
is_member = True

# Set discount based on membership status
discount = 20 if is_member else 5

print(discount)  # Output: 20
```

Conditional expressions can be used to improve messages printed for users.

```py
print("{0} file{1}".format((count if count != 0 else "no"), ("s" if count != 1 else "")))
```

###### <a name="chapter4part1.2"></a>Chapter 4 - Part 1.2: Looping

Python provides a ```while``` loop and a ```for …in``` loop

###### <a name="chapter4part1.3"></a>Chapter 4 - Part 1.3: While Loops

General syntax of the ```while``` loop

```
while boolean_expression:
  while_suite
else:
  else_suite
```

The ```else``` clause is optional. As long as the ```boolean_expression``` is ```True```, the ```while``` block’s suite is executed. If the ```boolean_expression``` is or becomes ```False```, the loop terminates, and if the optional ```else``` clause is present, its suite is executed.

```py
count = 0

while count < 5:
    print("Inside loop:", count)
    count += 1
else:
    print("Loop terminated normally.")

# Output:
# Inside loop: 0
# Inside loop: 1
# Inside loop: 2
# Inside loop: 3
# Inside loop: 4
# Loop terminated normally.
```

If the loop is terminated by a ```break``` statement, or a ```return``` statement (if the while is in a function or method) or an exception, the else clause is skipped.

```py
count = 0

while count < 5:
    if count == 3:
        break
    print("Inside loop:", count)
    count += 1
else:
    print("Loop terminated normally.")

# Output:
# Inside loop: 0
# Inside loop: 1
# Inside loop: 2
```

The ```continue``` immediately jumps back to the condition check.

```py
count = 0

while count < 5:
    count += 1
    if count == 3:
        continue
    print("Inside loop:", count)
else:
    print("Loop terminated normally.")

# Output:
# Inside loop: 1
# Inside loop: 2
# Inside loop: 4
# Inside loop: 5
# Loop terminated normally.
```

 If an exception occurs, the ```else``` clause is skipped.

 ```py
count = 0

try:
    while count < 5:
        if count == 3:
            raise ValueError("An error occurred")
        print("Inside loop:", count)
        count += 1
except ValueError as e:
    print("Exception:", e)
else:
    print("Loop terminated normally.")

# Output:
# Inside loop: 0
# Inside loop: 1
# Inside loop: 2
# Exception: An error occurred
```

###### <a name="chapter4part1.4"></a>Chapter 4 - Part 1.4: For Loops

Like a ```while``` loop, the full syntax of the ```for …in``` loop also includes an optional else clause:

```
for expression in iterable:
  for_suite
else:
  else_suite
```

The ```expression``` is normally either a single variable or a sequence of variables, usually in the form of a tuple. If a tuple or list is used for the ```expression```, each item is unpacked into the expression’s items.

is used to iterate over a sequence (such as a list, tuple, string, or range).

```py
for i in range(5):
    print("Inside loop:", i)
else:
    print("Loop completed all iterations.")

# Output:
# Inside loop: 0
# Inside loop: 1
# Inside loop: 2
# Inside loop: 3
# Inside loop: 4
# Loop completed all iterations.
```

If the loop is broken out of due to a ```break``` statement, or a ```return``` statement (if the loop is in a function or method), or if an exception is raised, the else clause’s suite is not executed.

```py
for i in range(5):
    if i == 3:
        break
    print("Inside loop:", i)
else:
    print("Loop completed all iterations.")

# Output:
# Inside loop: 0
# Inside loop: 1
# Inside loop: 2
```

If a ```continue``` statement is executed inside the ```for …in``` loop’s suite, control is immediately passed to the top of the loop and the next iteration begins.

```py
for i in range(5):
    if i == 3:
        continue
    print("Inside loop:", i)
else:
    print("Loop completed all iterations.")

# Output:
# Inside loop: 0
# Inside loop: 1
# Inside loop: 2
# Inside loop: 4
# Loop completed all iterations.
```

 If an exception occurs, the ```else``` clause is skipped.

 ```py
try:
    for i in range(5):
        if i == 3:
            raise ValueError("An error occurred")
        print("Inside loop:", i)
except ValueError as e:
    print("Exception:", e)
else:
    print("Loop completed all iterations.")

# Output:
# Inside loop: 0
# Inside loop: 1
# Inside loop: 2
# Exception: An error occurred
```


#### <a name="chapter4part2"></a>Chapter 4 - Part 2: Exception Handling

###### <a name="chapter4part2.1"></a>Chapter 4 - Part 2.1: Catching and Raising Exceptions

Exceptions are caught using try …except blocks, whose general syntax is:

```
try:
  try_suite
except exception_group1 as variable1:
  except_suite1
...
except exception_groupN as variableN:
  except_suiteN
else:
  else_suite
finally:
  finally_suite
```

There must be at least one ```except``` block, but both the ```else``` and the ```finally``` blocks are optional. The ```else``` block’s suite is executed when the ```try``` block’s suite has finished normally—but it is not executed if an exception occurs. If there is a ```finally``` block, it is always executed at the end.

```py
try:
    # Code that might raise an exception
    result = 10 / 0
except ZeroDivisionError as e:
    # Code that runs if a ZeroDivisionError occurs
    print("Error: Cannot divide by zero. Details:", e)
```

Each ```except``` clause’s exception group can be a single exception or a parenthesized tuple of exceptions. For each group, the ```as variable``` part is optional; if used, the variable contains the exception that occurred, and can be accessed in the exception block’s suite.

If an exception occurs in the ```try``` block’s suite, each ```except``` clause is tried in turn. If the exception matches an exception group, the corresponding suite is executed.

<br>

<div align="center"><img src="img/exceptionhierarchy-w700-h382.png" width=700 height=382><br><sub>Python’s exception hierarchy - (<a href='https://w3.cs.jmu.edu/lam2mo/cs240_2014_08/lab05-exceptions.html'>Work by w3.cs.jmu.edu</a>) </sub></div>

<br>

**Using else Block**

```py
try:
    result = 10 / 2
except ZeroDivisionError as e:
    print("Error:", e)
else:
    # Code that runs if no exceptions occur
    print("Division successful. Result:", result)
```

**Using finally Block**

```py
try:
    file = open("sample.txt", "r")
    content = file.read()
except FileNotFoundError as e:
    print("Error: File not found.", e)
finally:
    # This block always executes
    file.close()
    print("File closed.")
```

**Handling Multiple Exceptions**

```py
try:
    value = int("abc")  # This will raise a ValueError
except (ValueError, TypeError) as e:
    # This block handles both ValueError and TypeError
    print("ValueError or TypeError occurred. Details:", e)
```

If none of the ```except``` blocks matches the exception, Python will work itsway up the call stack looking for a suitable exception handler. If none is found the program will terminate and print the exception and a traceback on the console.

If no exceptions occur, any optional ```else``` block is executed. And in all cases—that is, if no exceptions occur, if an exception occurs and is handled, or if an exception occurs that is passed up the call stack—any ```finally``` block’s suite is always executed. If no exception occurs, or if an exception occurs and is handled by one of the ```except``` blocks, the ```finally``` block’s suite is executed at the end; but if an exception occurs that doesn’t match, first the ```finally``` block’s suite is executed, and then the exception is passed up the call stack. This guarantee of execution can be very useful when we want to ensure that resources are properly released.

**Normal Flow**

```
try:
  # process
except exception:
  # Not pass here, because no exception raise
finally:
  # cleanup
# continue here
```

**Handled Exception**

```
try:
  # process
except exception:
  # handle
finally:
  # cleanup
# continue here
```

**Unhandled Exception**

```
try:
  # process
except exception:
  # Not pass here, because exception raised not match
finally:
  # cleanup
# go up call stack
```


###### <a name="chapter4part2.2"></a>Chapter 4 - Part 2.2: Raising Exceptions

There are three syntaxes for raising exceptions:

```
raise exception(args)
raise exception(args) from original_exception
raise
```

**Basic Exception Raising**

```
raise exception(args)
```

This is the most common way to raise an exception.

```py
def divide(a, b):
    if b == 0:
        raise ZeroDivisionError("You cannot divide by zero.")
    return a / b

try:
    result = divide(10, 0)
except ZeroDivisionError as e:
    print("Caught exception:", e)

# Output: Caught exception: You cannot divide by zero.
```

**Exception Chaining**

```py
raise exception(args) from original_exception
```

This syntax is used to raise a new exception while preserving the context of the original exception.

```py
def process_data(data):
    if not data:
        raise ValueError("Data cannot be empty.")
    try:
        # Simulate an error during processing
        result = int(data)
    except ValueError as e:
        # Raise a new exception while preserving the original exception
        raise RuntimeError("Failed to process data.") from e

try:
    process_data("")
except RuntimeError as e:
    print("Caught exception:", e)
    print("Original exception:", e.__cause__)

# Output:
# Caught exception: Failed to process data.
# Original exception: Data cannot be empty.
```

**Re-Raising the Current Exception**

```
raise
```

This syntax is used to re-raise the current exception inside an except block.

```py
def divide(a, b):
    try:
        return a / b
    except ZeroDivisionError as e:
        print("Handling ZeroDivisionError, re-raising it...")
        raise  # Re-raise the current exception

try:
    result = divide(10, 0)
except ZeroDivisionError as e:
    print("Caught re-raised exception:", e)

# Output:
# Handling ZeroDivisionError, re-raising it...
# Caught re-raised exception: division by zero
```

###### <a name="chapter4part2.3"></a>Chapter 4 - Part 2.3: Custom Exceptions

Custom exceptions are custom data types (classes).

The base class should be ```Exception``` or a class that inherits from ```Exception```.

```
class ExceptionName(BaseException):
    pass
```

- ExceptionName: The name of your custom exception class. By convention, custom exception names end with Error (e.g., MyCustomError).

- BaseException: This is the base class from which your custom exception inherits. Typically, you inherit from Exception, which is a subclass of BaseException.

**Define a Custom Exception**

```py
class NegativeValueError(Exception):
    """Exception raised for errors in the input if it's negative."""
    def __init__(self, value, message="Value cannot be negative"):
        self.value = value
        self.message = message
        super().__init__(self.message)
```

- NegativeValueError inherits from Exception.

- __init__ method allows you to pass additional arguments (e.g., the value that caused the exception and a custom error message).

- The super().__init__(self.message) call ensures that the base class Exception is properly initialized with the message.

```py
def process_value(value):
    if value < 0:
        raise NegativeValueError(value)
    return value * 2

try:
    result = process_value(-5)
except NegativeValueError as e:
    print(f"Caught an exception: {e}")
    print(f"Value that caused the error: {e.value}")

# Output:
# Caught an exception: Value cannot be negative
# Value that caused the error: -5
```

**Custom Exception with Additional Attributes**

```py
class AuthenticationError(Exception):
    """Exception raised for authentication errors."""
    def __init__(self, user_id, message="Authentication failed"):
        self.user_id = user_id
        self.message = message
        super().__init__(self.message)

def authenticate_user(user_id, password):
    # Simulate authentication failure
    if password != "correct_password":
        raise AuthenticationError(user_id)

try:
    authenticate_user(123, "wrong_password")
except AuthenticationError as e:
    print(f"Error: {e}")
    print(f"User ID: {e.user_id}")

# Output:
# Error: Authentication failed
# User ID: 123
```

#### <a name="chapter4part3"></a>Chapter 4 - Part 3: Custom Functions

Functions are a means by whichwe can package up and parameterize functionality. Four kinds of functions can be created in Python: global functions, local functions, lambda functions, and methods.

- Global objects (including functions) are accessible to any code in the same module (i.e., the same .py file) in which the object is created. Global objects can also be accessed from other modules, as we will see in the next chapter.

- Local functions (also called nested functions) are functions that are defined inside other functions. These functions are visible only to the function where they are defined; they are especially useful for creating small helper functions that have no use elsewhere.

- Lambda functions are expressions, so they can be created at their point of use; however, they are much more limited than normal functions.

- Methods are functions that are associated with a particular data type and can be used only in conjunction with the data type

The general syntax for creating a (global or local) function is:

```
def functionName(parameters):
  suite
```

The parametersare optional,and if there is more than one they are written as a sequence of comma-separated identifiers, or as a sequence of identifier=value

```py
def heron(a, b, c):
  s = (a + b + c) / 2
    return math.sqrt(s * (s - a) * (s - b) * (s - c))
```

Inside the function, each parameter, a, b, and c, is initialized with the corresponding value that was passed as an argument. When the function is called, we must supply all of the arguments, for example, heron(3, 4, 5). If we give too
few or too many arguments, a TypeError exception will be raised. When we do a call like this we are said to be using positional arguments, because each argument passed is set as the value of the parameter in the corresponding position. So in this case, a is set to 3, b to 4, and c to 5, when the function is called.

Every function in Python returns a value, although it is perfectly acceptable (and common) to ignore the return value. The return value is either a single value or a tuple of values, and the values returned can be collections, so there are no practical limitations on what we can return. We can leave a function at any point by using the return statement. If we use return with no arguments, or if we don’t have a return statement at all, the function will return None.

Some functions have parameters for which there can be a sensible default.

```py
def letter_count(text, letters=string.ascii_letters):
  letters = frozenset(letters)
  count = 0
  for char in text:
    if char in letters:
      count += 1
  return count
```

We have specified a default value for the letters parameter by using the parameter=default syntax. This allows us to call letter_count() with just one argument, for example, letter_count("Maggie and Hopey"). Here, inside the function, letters will be the string that was given as the default value. But we can still change the default, for example, using an extra positional argument, letter_count("Maggie and Hopey", "aeiouAEIOU"), or using a keyword argument (covered next), letter_count("Maggie and Hopey", letters="aeiouAEIOU").

we are not forced to pass our arguments in the order they appear in the function’s definition—instead, we can use keyword arguments, passing each argument in the form name=value.

```py
def shorten(text, length=25, indicator="..."):
  if len(text) > length:
    text = text[:length - len(indicator)] + indicator
  return text
```

```py
shorten("The Silkie") # returns: 'The Silkie'
shorten(length=7, text="The Silkie") # returns: 'The ...'
shorten("The Silkie", indicator="&", length=7) # returns: 'The Si&'
shorten("The Silkie", 7, "&") # returns: 'The Si&'
```

Because both length and indicator have default values, either or both can be omitted entirely, in which case the default is used—this is what happens in the first call. In the second call we use keyword arguments for both of the specified parameters, so we can order them as we like. The third call mixes both positional and keyword arguments. We used a positional first argument (positional argumentsmust always precede keyword arguments),and then two keyword arguments. The fourth call simply uses positional arguments.

###### <a name="chapter4part3.1"></a>Chapter 4 - Part 3.1: Names and Docstrings

Using good names for a function and its parameters goes a long way toward making the purpose and use of the function clear to other programmers

- Use a naming scheme, and use it consistently. Use UPPERCASE for constants, TitleCase for classes (including exceptions), camel- Case for GUI (Graphical User Interface) functions and methods.
  
- For all names, avoid abbreviations, unless they are both standardized and widely used.

- Be proportional with variable and parameter names: x is a perfectly good name for an x-coordinate and i is fine for a loop counter, but in general the name should be long enough to be descriptive. The name should describe the data’s meaning rather than its type (e.g., amount_due rather than money), unless the use is generic to a particular type

- Functions and methods should have names that say what they do or what they return (depending on their emphasis), but never how they do it

```
def find(l, s, i=0): # BAD
def linear_search(l, s, i=0): # BAD
def first_index_of(sorted_name_list, name, start=0): # GOOD
```

We can add documentation to any function by using a docstring—this is simply a string that comes immediately after the def line, and before the function’s code proper begins.

```py
def calculate_area(radius):
    """
    Calculate the area of a circle given its radius.

    Parameters:
    radius (float): The radius of the circle. Must be a non-negative number.

    Returns:
    float: The area of the circle.

    Raises:
    ValueError: If the radius is negative.

    Example:
    >>> calculate_area(5)
    78.53981633974483

    Notes:
    The formula for the area of a circle is π * radius^2.
    """
    if radius < 0:
        raise ValueError("Radius cannot be negative")
    import math
    return math.pi * radius ** 2
```

###### <a name="chapter4part3.2"></a>Chapter 4 - Part 3.2: Argument and Parameter Unpacking

In Python, the sequence unpacking operator * can be used to supply positional arguments to functions. This feature is handy when you have a sequence (like a list or tuple) and you want to pass its elements as separate positional arguments to a function.

The tuple values is unpacked into the print_values function, which takes three arguments.

```py
def function_name(arg1, arg2, arg3):
    pass

sequence = (1, 2, 3)
function_name(*sequence)
```

You can also combine unpacked arguments with additional arguments or keyword arguments.

```py
def display_info(name, age, city, country="USA"):
    print(f"{name}, {age} years old, lives in {city}, {country}.")

person_info = ("Bob", 25, "Los Angeles")
display_info(*person_info, country="Canada")

# Output: Bob, 25 years old, lives in Los Angeles, Canada.
```

you can use * before a parameter name to collect any additional positional arguments into a tuple. This is often referred to as "variable-length arguments" or "varargs."

```py
def function_name(param1, param2, *args):
    pass
```

- param1 and param2 are regular positional parameters.
- *args collects any additional positional arguments into a tuple named args.

```py
def product(*args):
  result = 1
  for arg in args:
    result *= arg
  return result
```

This function has one parameter called args. Having the * in front means that inside the function the args parameter will be a tuple with its items set to however many positional arguments are given.

```py
product(1, 2, 3, 4) # args == (1, 2, 3, 4); returns: 24
product(5, 3, 8) # args == (5, 3, 8); returns: 120
product(11) # args == (11,); returns: 11
```

We can have keyword arguments following positional arguments

```py
def describe_person(name, age, *hobbies):
    print(f"{name} is {age} years old and enjoys:")
    for hobby in hobbies:
        print(f"- {hobby}")

describe_person("Alice", 30, "reading", "cycling", "hiking")

# Output:
# Alice is 30 years old and enjoys:
# - reading
# - cycling
# - hiking
```

is also possible to use * as a “parameter” in its own right.

```
def function_name(positional_arg1, positional_arg2, *, keyword_only_arg1, keyword_only_arg2):
    pass
```

- positional_arg1 and positional_arg2 are positional parameters.
- * signifies that the following parameters must be provided as keyword arguments.
- keyword_only_arg1 and keyword_only_arg2 must be specified using their names when calling the function.

```py
def heron2(a, b, c, *, units="square meters"):
  s = (a + b + c) / 2
  area = math.sqrt(s * (s - a) * (s - b) * (s - c))
  return "{0} {1}".format(area, units)
```

```py
heron2(25, 24, 7) # returns: '84.0 square meters'
heron2(41, 9, 40, units="sq. inches") # returns: '180.0 sq. inches'
heron2(25, 24, 7, "sq. inches") # WRONG! raises TypeError
```

```py
def register_user(username, email, *, age=None, country='USA'):
    print(f"Username: {username}")
    print(f"Email: {email}")
    print(f"Age: {age}")
    print(f"Country: {country}")

# Valid call:
register_user("john_doe", "john@example.com", age=30, country="Canada")

# Invalid call (will raise a TypeError):
# register_user("john_doe", "john@example.com", 30, "Canada")
```

Mixing Positional and Keyword-Only Parameters

```py
def create_order(item, quantity, *, discount=None, gift_wrap=False):
    print(f"Item: {item}")
    print(f"Quantity: {quantity}")
    print(f"Discount: {discount}")
    print(f"Gift Wrap: {gift_wrap}")

# Valid call:
create_order("Laptop", 1, discount=10, gift_wrap=True)

# Invalid call (will raise a TypeError):
# create_order("Laptop", 1, 10, True)
```

you can use the ** operator to unpack a dictionary (or any mapping) into keyword arguments when calling a function. This is known as "dictionary unpacking" or "mapping unpacking." It allows you to pass the contents of a dictionary as keyword arguments to a function.

```py
options = dict(paper="A4", color=True)
print_setup(**options)
```

```py
def display_info(name, age, country):
    print(f"Name: {name}")
    print(f"Age: {age}")
    print(f"Country: {country}")

info = {"name": "Alice", "age": 30, "country": "Canada"}
display_info(**info)

# Output:
# Name: Alice
# Age: 30
# Country: Canada
```

```py
def create_profile(username, email, *, age=None, country='USA'):
    print(f"Username: {username}")
    print(f"Email: {email}")
    print(f"Age: {age}")
    print(f"Country: {country}")

profile_info = {"age": 25, "country": "UK"}
create_profile("john_doe", "john@example.com", **profile_info)

# Output:
# Username: john_doe
# Email: john@example.com
# Age: 25
# Country: UK
```

```py
def print_args(*args, **kwargs):
  for i, arg in enumerate(args):
    print("positional argument {0} = {1}".format(i, arg))
  for key in kwargs:
    print("keyword argument {0} = {1}".format(key, kwargs[key]))
```

###### <a name="chapter4part3.3"></a>Chapter 4 - Part 3.3: Accessing Variables in the Global Scope

It is sometimes convenient to have a few global variables that are accessed by various functions in the program. This is usually okay for “constants”

The ```global``` statement in Python is used to declare that a variable inside a function refers to a variable defined at the global scope, rather than a local variable. 

```py
global variable_name
```

**Modifying a Global Variable**

```py
# Global variable
counter = 0

def increment():
    global counter
    counter += 1

print(counter)  # Output: 0
increment()
print(counter)  # Output: 1
```

**Global Variable in Multiple Functions**

```py
# Global variable
total = 100

def add(amount):
    global total
    total += amount

def subtract(amount):
    global total
    total -= amount

print(total)  # Output: 100
add(50)
print(total)  # Output: 150
subtract(20)
print(total)  # Output: 130
```

**Using Global Variables with Functions**

```py
# Global variable
settings = {
    "theme": "light",
    "font_size": 12
}

def update_settings(theme=None, font_size=None):
    global settings
    if theme:
        settings["theme"] = theme
    if font_size:
        settings["font_size"] = font_size

print(settings)  # Output: {'theme': 'light', 'font_size': 12}
update_settings(theme="dark", font_size=14)
print(settings)  # Output: {'theme': 'dark', 'font_size': 14}
```

###### <a name="chapter4part3.4"></a>Chapter 4 - Part 3.4: Lambda Functions

Lambda functions are functions created using the following syntax:

```
lambda parameters: expression
```

The parameters are optional, and if supplied they are normally just commaseparated variable names, that is, positional arguments,although the complete argument syntax supported by def statementscan be used. The expression cannot contain branches or loops (although conditional expressions are allowed), and cannot have a return (or yield) statement. The result of a lambda expression is an anonymous function. When a lambda function is called it returns the result of computing the expression as its result. If the expression is a tuple it should be enclosed in parentheses.

```py
# Lambda function to add two numbers
add = lambda x, y: x + y

print(add(5, 3))  # Output: 8
```

**Lambda Function as an Argument**

Lambda functions are often used as arguments to higher-order functions like map(), filter(), and sorted().

```py
# Using lambda with map() to square numbers
numbers = [1, 2, 3, 4, 5]
squared_numbers = list(map(lambda x: x ** 2, numbers))

print(squared_numbers)  # Output: [1, 4, 9, 16, 25]
```

map() applies the lambda function lambda x: x ** 2 to each element of the list numbers, producing a new list with squared values.

**Lambda Function with filter()**

filter() applies the lambda function lambda x: x % 2 == 0 to filter out only even numbers from the list numbers.

```py
# Using lambda with filter() to find even numbers
numbers = [1, 2, 3, 4, 5]
even_numbers = list(filter(lambda x: x % 2 == 0, numbers))

print(even_numbers)  # Output: [2, 4]
```

**Lambda Function with sorted()**

sorted() uses the lambda function lambda x: x[1] to sort the list of tuples based on the second element of each tuple.

```py
# Using lambda with sorted() to sort by the second element in tuples
data = [(1, 'apple'), (2, 'banana'), (3, 'cherry')]
sorted_data = sorted(data, key=lambda x: x[1])

print(sorted_data)  # Output: [(1, 'apple'), (2, 'banana'), (3, 'cherry')]
```

###### <a name="chapter4part3.5"></a>Chapter 4 - Part 3.5: Assertions

Preconditions and postconditions can be specified using assert statements, which have the syntax:

```
assert boolean_expression, optional_expression
```

If the ```boolean_expression``` evaluates to ```False``` an ```AssertionError``` exception is raised. If the optional ```optional_expression``` is given, it is used as the argument to the ```AssertionError``` exception

```py
def divide(a, b):
    assert b != 0, "Division by zero is not allowed"
    return a / b

print(divide(10, 2))  # Output: 5.0

# This will raise an AssertionError
print(divide(10, 0))  # Raises: AssertionError: Division by zero is not allowed
```

The assert statement checks if b is not zero before performing the division. If b is zero, an AssertionError is raised with the message "Division by zero is not allowed".

**Preconditions**

Preconditions are conditions that must be true before executing a function or a piece of code.

```py
def withdraw(amount, balance):
    assert amount > 0, "Withdrawal amount must be positive"
    assert amount <= balance, "Insufficient funds"
    balance -= amount
    return balance

print(withdraw(50, 100))  # Output: 50

# These will raise AssertionErrors
print(withdraw(-10, 100))  # Raises: AssertionError: Withdrawal amount must be positive
print(withdraw(150, 100))  # Raises: AssertionError: Insufficient funds
```

The assert statements check preconditions: that the withdrawal amount is positive and that it does not exceed the balance.

**Postconditions**

Postconditions are conditions that should be true after executing a function or a piece of code.

```py
def add_numbers(a, b):
    result = a + b
    assert result >= a, "Result should be greater than or equal to the first operand"
    assert result >= b, "Result should be greater than or equal to the second operand"
    return result

print(add_numbers(3, 5))  # Output: 8

# This will raise an AssertionError if the condition fails
print(add_numbers(-3, -5))  # Output: -8, but no assertion error is raised here
```

The assert statements ensure that the result of the addition meets expected postconditions.

## <a name="chapter5"></a>Chapter 5: Modules

#### <a name="chapter5part1"></a>Chapter 5 - Part 1: Modules and Packages

###### <a name="chapter5part1.1"></a>Chapter 5 - Part 1.1: Packages

###### <a name="chapter5part1.2"></a>Chapter 5 - Part 1.2: Custom Modules

###### <a name="chapter5part1.3"></a>Chapter 5 - Part 1.3: The TextUtil Module

###### <a name="chapter5part1.4"></a>Chapter 5 - Part 1.4: The CharGrid Module

#### <a name="chapter5part2"></a>Chapter 5 - Part 2: Overview of Python’s Standard Library

###### <a name="chapter5part2.1"></a>Chapter 5 - Part 2.1: String Handling

###### <a name="chapter5part2.2"></a>Chapter 5 - Part 2.2: Command-Line Programming

###### <a name="chapter5part2.3"></a>Chapter 5 - Part 2.3: Mathematics and Numbers

###### <a name="chapter5part2.4"></a>Chapter 5 - Part 2.4: Times and Dates

###### <a name="chapter5part2.5"></a>Chapter 5 - Part 2.5: Algorithms and Collection Data Types

###### <a name="chapter5part2.6"></a>Chapter 5 - Part 2.6: File Formats, Encodings, and Data Persistence

###### <a name="chapter5part2.7"></a>Chapter 5 - Part 2.7: File, Directory, and Process Handling

###### <a name="chapter5part2.8"></a>Chapter 5 - Part 2.8: Networking and Internet Programming

###### <a name="chapter5part2.9"></a>Chapter 5 - Part 2.9: XML

###### <a name="chapter5part2.10"></a>Chapter 5 - Part 2.10: Other Modules

## <a name="chapter6"></a>Chapter 6: Object-Oriented Programming

#### <a name="chapter6part1"></a>Chapter 6 - Part 1: The Object-Oriented Approach

###### <a name="chapter6part1.1"></a>Chapter 6 - Part 1.1: Object-Oriented Concepts and Terminology

#### <a name="chapter6part2"></a>Chapter 6 - Part 2: Custom Classes

###### <a name="chapter6part2.1"></a>Chapter 6 - Part 2.1: Attributes and Methods

###### <a name="chapter6part2.2"></a>Chapter 6 - Part 2.2: Inheritance and Polymorphism

###### <a name="chapter6part2.3"></a>Chapter 6 - Part 2.3: Using Properties to Control Attribute Access

###### <a name="chapter6part2.4"></a>Chapter 6 - Part 2.4: Creating Complete Fully Integrated Data Types

###### <a name="chapter6part2.5"></a>Chapter 6 - Part 2.5: Creating Data Types from Scratch

###### <a name="chapter6part2.6"></a>Chapter 6 - Part 2.6: Creating Data Types from Other Data Types

#### <a name="chapter6part3"></a>Chapter 6 - Part 3: Custom Collection Classes

###### <a name="chapter6part3.1"></a>Chapter 6 - Part 3.1: Creating Classes That Aggregate Collections

###### <a name="chapter6part3.2"></a>Chapter 6 - Part 3.2: Creating Collection Classes Using Aggregation

###### <a name="chapter6part3.3"></a>Chapter 6 - Part 3.3: Creating Collection Classes Using Inheritance

## <a name="chapter7"></a>Chapter 7: File Handling

#### <a name="chapter7part1"></a>Chapter 7 - Part 1: Writing and Reading Binary Data

###### <a name="chapter7part1.1"></a>Chapter 7 - Part 1.1: Pickles with Optional Compression

###### <a name="chapter7part1.2"></a>Chapter 7 - Part 1.2: Raw Binary Data with Optional Compression

#### <a name="chapter7part2"></a>Chapter 7 - Part 2: Writing and Parsing Text Files

###### <a name="chapter7part2.1"></a>Chapter 7 - Part 2.1: Writing Text

###### <a name="chapter7part2.2"></a>Chapter 7 - Part 2.2: Parsing Text

###### <a name="chapter7part2.3"></a>Chapter 7 - Part 2.3: Parsing Text Using Regular Expressions

#### <a name="chapter7part3"></a>Chapter 7 - Part 3: Writing and Parsing XML Files

###### <a name="chapter7part3.1"></a>Chapter 7 - Part 3.1: Element Trees

###### <a name="chapter7part3.2"></a>Chapter 7 - Part 3.2: DOM (Document Object Model

###### <a name="chapter7part3.3"></a>Chapter 7 - Part 3.3: Manually Writing XML

###### <a name="chapter7part3.4"></a>Chapter 7 - Part 3.4: Parsing XML with SAX (Simple API for XML)

#### <a name="chapter7part4"></a>Chapter 7 - Part 4: Random Access Binary Files

###### <a name="chapter7part4.1"></a>Chapter 7 - Part 4.1: A Generic BinaryRecordFile Class

## <a name="appendixa"></a>Appendix A: Useful Python Code Snippet

#### <a name="appendixapart1"></a>Appendix A - Part 1: Create a Log file

```py
import logging
import os
from datetime import datetime

# CONST

LOG_PREFIX_NAME_CONST = 'MYLOGGER_'
LOG_FILE_NAME_CONST = 'myloggername_log_file'
LOG_DIR_NAME_CONST = 'myloggerfolder-logs'
LOG_DEFAULT_VALUE = logging.INFO

logger = None  # Initialize the logger variable

def main():
    log_prefix_name = LOG_PREFIX_NAME_CONST
    log_file_name = LOG_FILE_NAME_CONST
    log_dir_name = LOG_DIR_NAME_CONST

    global logger
    logger = setup_logger(log_prefix_name, level=LOG_DEFAULT_VALUE, log_file_prefix=log_file_name, log_dir=log_dir_name)

    logger_execute()

def setup_logger(name, level, log_file_prefix, log_dir):
    global logger

    # Ensure the log directory exists
    if not os.path.exists(log_dir):
        os.makedirs(log_dir)

    # Create a logger object
    logger = logging.getLogger(name)
    logger.setLevel(level)

    # Get the current date to include in the log file name
    current_date = datetime.now().strftime('%Y-%m-%d')
    log_file = os.path.join(log_dir, '{log_file_prefix}_{current_date}.log'.format(log_file_prefix=log_file_prefix,
                                                                                   current_date=current_date))

    # Create a file handler
    file_handler = logging.FileHandler(log_file)
    file_handler.setLevel(level)

    # Create a log format
    formatter = logging.Formatter('%(asctime)s - %(name)s - %(levelname)s - %(message)s')
    file_handler.setFormatter(formatter)

    # Add the file handler to the logger
    if not logger.handlers:
        logger.addHandler(file_handler)

    return logger

def logger_execute():
    global logger
    logger.info('------------ Executing MYLOGGER INFO ------------')
    logger.error('------------ Executing MYLOGGER ERROR ------------')

if __name__ == "__main__":
    main()

```

#### <a name="appendixapart2"></a>Appendix A - Part 2: List all files of a directory based in a extension

```py
import os


def main():
    directory_files = list_files_in_directory(os.getcwd(), 'json')
    for file in directory_files:
        print(file)


def list_files_in_directory(directory, file_extension):
    directory_files = []
    if os.path.isdir(directory):
        try:
            items = os.listdir(directory)
            for item in items:
                item_path = os.path.join(directory, item)
                if os.path.isfile(item_path) and item_path.endswith('.%s' % file_extension):
                    directory_files.append(item)
            return directory_files
        except OSError as error:
            print("Error accessing directory: %s" % error)
    else:
        print("%s is not a valid directory." % directory)
    return directory_files


if __name__ == "__main__":
    main()

```

#### <a name="appendixapart3"></a>Appendix A - Part 3: List all files of a directory based in a regex

```py
import os
import re


def main():
    directory_files = list_files_in_directory(os.getcwd(), r'.*\.csv$')
    for file in directory_files:
        print(file)


def list_files_in_directory(directory, file_regex):
    directory_files = []
    if os.path.isdir(directory):
        try:
            items = os.listdir(directory)
            regex = re.compile(file_regex)
            for item in items:
                item_path = os.path.join(directory, item)
                if os.path.isfile(item_path) and regex.match(item):
                    directory_files.append(item)
            return directory_files
        except OSError as error:
            print("Error accessing directory: %s" % error)
    else:
        print("%s is not a valid directory." % directory)
    return directory_files


if __name__ == "__main__":
    main()

```

#### <a name="appendixapart4"></a>Appendix A - Part 4: Move file to a directory

```py
import os
import shutil


def main():
    move_file_to_dir('test.csv', 'abc', False)


def move_file_to_dir(file, dir_name, overwrite=False):
    # Ensure the directory exists
    if not os.path.exists(dir_name):
        os.makedirs(dir_name)

    src_file_path = None
    dst_folder = None
    dst_file_path = None
    try:
        src_file_path = os.path.abspath(file)
        dst_folder = os.path.abspath(dir_name)
        dst_file_path = os.path.join(dst_folder, os.path.basename(src_file_path))

        # Check if the destination file exists
        if os.path.exists(dst_file_path):
            if overwrite:
                print('File {} already exist in the destination folder {}: '
                      'Overwrite the file'.format(src_file_path, dst_folder))
                os.remove(dst_file_path)
            else:
                raise Exception('File already exists at destination: {}'.format(dst_file_path))

        shutil.move(src_file_path, dst_folder)

    except Exception as error:
        print('Error in move files from {} to {}: {}'.format(src_file_path, dst_folder, error))

    return dst_file_path


if __name__ == "__main__":
    main()

```

#### <a name="appendixapart5"></a>Appendix A - Part 5: Read a Config Json File

config_file.json

```json
{
	"configOne": "example_1",
	"configTwo": "example_2",
	"dataConfig": {
		"product": {
			"columnsMapper": {
				"columnOne": "column1",
				"columnTwo": "column2",
				"columnThree": "column3",
				"columnFour": "column4"
			}
		},
		"item": {
			"columnsMapper": {
				"columnOne": "column1",
				"columnTwo": "column2"
			}
		}
	}
}
```

```py
import json
import os
from collections import OrderedDict


def main():
    config_file = load_json_config('config_file.json')

    config_one = config_file['configOne']
    config_two = config_file['configTwo']

    print(config_one)
    print(config_two)

    data_config = config_file['dataConfig']

    # Read each object of dataConfig node
    for key, value in data_config.items():
        columns_mapper = value['columnsMapper']

        print(key)
        print(columns_mapper)


def load_json_config(json_file):
    try:
        json_file_path = os.path.abspath(json_file)
        with open(json_file_path, 'r') as file:
            return json.load(file, object_pairs_hook=OrderedDict)

    except Exception as error:
        print(error)


if __name__ == "__main__":
    main()

```

#### <a name="appendixapart6"></a>Appendix A - Part 6: Read and Parse a CSV file with Pandas based in a Config Json File

config_file.json

```json

{
	"configOne": "example_1",
	"configTwo": "example_2",
	"dataConfig": {
		"product": {
			"fileName": "product_file",
			"columnsMapper": {
				"columnOne": "column1",
				"columnTwo": "column2",
				"columnThree": "column3",
				"columnFour": "column4"
			}
		},
		"item": {
			"fileName": "item_file",
			"columnsMapper": {
				"columnOne": "column1",
				"columnTwo": "column2"
			}
		}
	}
}

```

test.csv

```csv
"column1","column2","column3","column4"
"1","","3","4"
"5","","7","8"
"a","","c","d"
"e","","g","h"
"i","","l","m"
"n","","p","q"
```

```py
import json
import os
from collections import OrderedDict

import pandas as pd


def main():
    config_file = load_json_config('config_file.json')

    data_config = config_file['dataConfig']

    # Read each object of dataConfig node
    for key, value in data_config.items():
        final_file_name = value['fileName']
        columns_mapper = value['columnsMapper']

        create_csv_with_clean_data('test.csv', columns_mapper, final_file_name, key)


def load_json_config(json_file):
    try:
        json_file_path = os.path.abspath(json_file)
        with open(json_file_path, 'r') as file:
            return json.load(file, object_pairs_hook=OrderedDict)

    except Exception as error:
        print(error)


def create_csv_with_clean_data(file_path, columns_mapper, final_file_name, key):
    try:
        df = pd.read_csv(file_path)

        new_df = map_df_columns_to_file_config(df, columns_mapper)

        if key == 'item':
            new_df['columnTwo'] = new_df['columnTwo'].apply(fill_empty_field_with_value)

        new_df.to_csv(final_file_name, sep='|', index=False)

    except Exception as error:

        print(error)

        raise


def fill_empty_field_with_value(column_two_value):
    if pd.isna(column_two_value):
        column_two_value = 'someValue'
    return column_two_value


def map_df_columns_to_file_config(df, columns_mapper):
    new_columns = OrderedDict()

    for output_col, input_col in columns_mapper.items():
        if input_col:
            # Check if input_col exist in the df
            if input_col in df.columns:
                new_columns[output_col] = df[input_col]
            # If not, is a fixed value
            else:
                new_columns[output_col] = input_col
        else:
            new_columns[output_col] = ""

    return pd.DataFrame(new_columns)


if __name__ == "__main__":
    main()
```

#### <a name="appendixapart7"></a>Appendix A - Part 7: Read a CSV file with Pandas and iteract over the rows with custom functions using apply()

config_file.json

```json
{
	"configOne": "example_1",
	"configTwo": "example_2",
	"dataConfig": {
		"product": {
			"fileName": "product_file",
			"columnsMapper": {
				"columnOne": "column1",
				"columnTwo": "column2",
				"columnThree": "column3",
				"columnFour": ""
			}
		},
		"item": {
			"fileName": "item_file",
			"columnsMapper": {
				"columnOne": "column1",
				"columnTwo": "column2"
			}
		}
	}
}
```

test.csv

```csv
"column1","column2","column3","column4"
"1","2 v","3","4"
"5","6 x ","7","8"
"9","10","11","12"
"13","","15","16"
"17","","19","20"
"21","","23","24"
```

```py
import json
import os
from collections import OrderedDict

import pandas as pd


def main():
    config_file = load_json_config('config_file.json')

    data_config = config_file['dataConfig']

    # Read each object of dataConfig node
    for key, value in data_config.items():
        final_file_name = value['fileName']
        columns_mapper = value['columnsMapper']

        create_csv_with_clean_data('test.csv', columns_mapper, final_file_name, key)


def load_json_config(json_file):
    try:
        json_file_path = os.path.abspath(json_file)
        with open(json_file_path, 'r') as file:
            return json.load(file, object_pairs_hook=OrderedDict)

    except Exception as error:
        print(error)


def create_csv_with_clean_data(file_path, columns_mapper, final_file_name, key):
    try:
        df = pd.read_csv(file_path)

        new_df = map_df_columns_to_file_config(df, columns_mapper)

        if key == 'product':
            new_df = new_df.apply(split_and_fill_columns_with_split_result, axis=1, column_to_split='columnTwo', columns_to_fill=['columnTwo', 'columnFour'])
        if key == 'item':
            new_df = new_df.apply(split_and_fill_columns_with_split_result, axis=1, column_to_split='columnTwo', columns_to_fill=['columnTwo'])


        new_df.to_csv(final_file_name, sep='|', index=False)

    except Exception as error:

        print(error)

        raise


def fill_empty_field_with_value(column_two_value):
    if pd.isna(column_two_value):
        column_two_value = 'someValue'
    return column_two_value


def split_and_fill_columns_with_split_result(row, column_to_split=None, columns_to_fill=None, split_pattern=None):
    if isinstance(row[column_to_split], str) and row[column_to_split]:
        parts = row[column_to_split].split(split_pattern)
    else:
        parts = []

    for i, column in enumerate(columns_to_fill):
        if i < len(parts):
            row[column] = parts[i]
        else:
            row[column] = ''

    return row


def map_df_columns_to_file_config(df, columns_mapper):
    new_columns = OrderedDict()

    for output_col, input_col in columns_mapper.items():
        if input_col:
            # Check if input_col exist in the df
            if input_col in df.columns:
                new_columns[output_col] = df[input_col]
            # If not, is a fixed value
            else:
                new_columns[output_col] = input_col
        else:
            new_columns[output_col] = ""

    return pd.DataFrame(new_columns)


if __name__ == "__main__":
    main()
```
