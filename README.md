<h1 align="center"> Python </h1>

# Content

1. [Chapter 1: Rapid Introduction to Procedural Programming](#chapter1)
    - [Chapter 1 - Part 1: Creating and Running Python Programs](#chapter1part1)
    - [Chapter 1 - Part 2: Data Types in Python](#chapter1part2)
    - [Chapter 1 - Part 3: Object References in Python](#chapter1part3)
    - [Chapter 1 - Part 4: Collection Data Types in Python](#chapter1part4)
    - [Chapter 1 - Part 5: Logical Operations in Python](#chapter1part5)
      - [Chapter 1 - Part 5.1: The Identity Operator](#chapter1part5.1)
      - [Chapter 1 - Part 5.2: Comparison Operators](#chapter1part5.2)
      - [Chapter 1 - Part 5.3: The Membership Operator](#chapter1part5.3)
      - [Chapter 1 - Part 5.4: Logical Operators](#chapter1part5.4)
    - [Chapter 1 - Part 6: Control Flow Statements in Python](#chapter1part6)
      - [Chapter 1 - Part 6.1: The if Statement](#chapter1part6.1)
      - [Chapter 1 - Part 6.2: The while Statement](#chapter1part6.2)
      - [Chapter 1 - Part 6.3: The for …in Statement](#chapter1part6.3)
      - [Chapter 1 - Part 6.4: Basic Exception Handling](#chapter1part6.4)
    - [Chapter 1 - Part 7: Arithmetic Operators in Python](#chapter1part7)
    - [Chapter 1 - Part 8: Input/Output in Python](#chapter1part8)
    - [Chapter 1 - Part 9: Creating and Calling Functions in Python](#chapter1part9)
2. [Chapter 2: Data Types](#chapter2)
    - [Chapter 2 - Part 1: Identifiers and Keywords](#chapter2part1)
    - [Chapter 2 - Part 2: Integral Types](#chapter2part2)
      - [Chapter 2 - Part 2.1: Integers](#chapter2part2.1)
      - [Chapter 2 - Part 2.2: Booleans](#chapter2part2.2)
      - [Chapter 2 - Part 2.3: Integer Bitwise Operators](#chapter2part2.3)
    - [Chapter 2 - Part 3: Floating-Point Types](#chapter2part3)
      - [Chapter 2 - Part 3.1: Floating-Point Numbers](#chapter2part3.1)
      - [Chapter 2 - Part 3.2: Complex Numbers](#chapter2part3.2)
      - [Chapter 2 - Part 3.3: Decimal Numbers](#chapter2part3.3)
    - [Chapter 2 - Part 4: Strings](#chapter2part4)
      - [Chapter 2 - Part 4.1: Comparing Strings](#chapter2part4.1)
      - [Chapter 2 - Part 4.2: Slicing and Striding Strings](#chapter2part4.2)
      - [Chapter 2 - Part 4.3: String Operators and Methods](#chapter2part4.3)
      - [Chapter 2 - Part 4.4: String Formatting with the str.format() Method](#chapter2part4.4)
      - [Chapter 2 - Part 4.5: Field Names](#chapter2part4.5)
      - [Chapter 2 - Part 4.6: Conversions](#chapter2part4.6)
      - [Chapter 2 - Part 4.7: Format Specifications](#chapter2part4.7)
      - [Chapter 2 - Part 4.8: Character Encodings](#chapter2part4.8)
3. [Chapter 3: Collection Data Types](#chapter3)
    - [Chapter 3 - Part 1: Sequence Types](#chapter3part1)
      - [Chapter 3 - Part 1.1: Tuples](#chapter3part1.1)
      - [Chapter 3 - Part 1.2: Named Tuples](#chapter3part1.2)
      - [Chapter 3 - Part 1.3: Lists](#chapter3part1.3)
      - [Chapter 3 - Part 1.4: List Comprehensions](#chapter3part1.4)
    - [Chapter 3 - Part 2: Set Types](#chapter3part2)
      - [Chapter 3 - Part 2.1: Sets](#chapter3part2.1)
      - [Chapter 3 - Part 2.2: Set Comprehensions](#chapter3part2.2)
      - [Chapter 3 - Part 2.3: Frozen Sets](#chapter3part2.3) 
    - [Chapter 3 - Part 3: Mapping Types](#chapter3part3)
      - [Chapter 3 - Part 3.1: Dictionaries](#chapter3part3.1)
      - [Chapter 3 - Part 3.2: Dictionary Comprehensions](#chapter3part3.2)
      - [Chapter 3 - Part 3.3: Default Dictionaries](#chapter3part3.3)
      - [Chapter 3 - Part 3.4: Ordered Dictionaries](#chapter3part3.4)
    - [Chapter 3 - Part 4: Iterating and Copying Collections](#chapter3part4)
      - [Chapter 3 - Part 4.1: Iterators and Iterable Operations and Functions](#chapter3part4.1)
      - [Chapter 3 - Part 4.2: Copying Collections](#chapter3part4.2)
4. [Chapter 4: Control Structures and Functions](#chapter4)
    - [Chapter 4 - Part 1: Control Structures](#chapter4part1)
      - [Chapter 4 - Part 1.1: Conditional Branching](#chapter4part1.1)
      - [Chapter 4 - Part 1.2: Looping](#chapter4part1.2)
      - [Chapter 4 - Part 1.3: While Loops](#chapter4part1.3)
      - [Chapter 4 - Part 1.4: For Loops](#chapter4part1.4)
    - [Chapter 4 - Part 2: Exception Handling](#chapter4part2)
      - [Chapter 4 - Part 2.1: Catching and Raising Exceptions](#chapter4part2.1)
      - [Chapter 4 - Part 2.2: Raising Exceptions](#chapter4part2.2)
      - [Chapter 4 - Part 2.3: Custom Exceptions](#chapter4part2.3)
    - [Chapter 4 - Part 3: Custom Functions](#chapter4part3)
      - [Chapter 4 - Part 3.1: Names and Docstrings](#chapter4part3.1)
      - [Chapter 4 - Part 3.2: Argument and Parameter Unpacking](#chapter4part3.2)
      - [Chapter 4 - Part 3.3: Accessing Variables in the Global Scope](#chapter4part3.3)
      - [Chapter 4 - Part 3.4: Lambda Functions](#chapter4part3.4)
      - [Chapter 4 - Part 3.5: Assertions](#chapter4part3.5)
5. [Chapter 5: Modules](#chapter5)
    - [Chapter 5 - Part 1: Modules and Packages](#chapter5part1)
      - [Chapter 5 - Part 1.1: Packages](#chapter5part1.1)
      - [Chapter 5 - Part 1.2: Custom Modules](#chapter5part1.2)
      - [Chapter 5 - Part 1.3: The TextUtil Module](#chapter5part1.3)
      - [Chapter 5 - Part 1.4: The CharGrid Module](#chapter5part1.4)
    - [Chapter 5 - Part 2: Overview of Python’s Standard Library](#chapter5part2)
      - [Chapter 5 - Part 2.1: String Handling](#chapter5part2.1)
      - [Chapter 5 - Part 2.2: Command-Line Programming](#chapter5part2.2)
      - [Chapter 5 - Part 2.3: Mathematics and Numbers](#chapter5part2.3)
      - [Chapter 5 - Part 2.4: Times and Dates](#chapter5part2.4)
      - [Chapter 5 - Part 2.5: Algorithms and Collection Data Types](#chapter5part2.5)
      - [Chapter 5 - Part 2.6: File Formats, Encodings, and Data Persistence](#chapter5part2.6)
      - [Chapter 5 - Part 2.7: File, Directory, and Process Handling](#chapter5part2.7)
      - [Chapter 5 - Part 2.8: Networking and Internet Programming](#chapter5part2.8)
      - [Chapter 5 - Part 2.9: XML](#chapter5part2.9)
      - [Chapter 5 - Part 2.10: Other Modules](#chapter5part2.10)  
6. [Chapter 6: Object-Oriented Programming](#chapter6)
    - [Chapter 6 - Part 1: The Object-Oriented Approach](#chapter6part1)
      - [Chapter 6 - Part 1.1: Object-Oriented Concepts and Terminology](#chapter6part1.1)
    - [Chapter 6 - Part 2: Custom Classes](#chapter6part2)
      - [Chapter 6 - Part 2.1: Attributes and Methods](#chapter6part2.1)
      - [Chapter 6 - Part 2.2: Inheritance and Polymorphism](#chapter6part2.2)
      - [Chapter 6 - Part 2.3: Using Properties to Control Attribute Access](#chapter6part2.3)
      - [Chapter 6 - Part 2.4: Creating Complete Fully Integrated Data Types](#chapter6part2.4)
      - [Chapter 6 - Part 2.5: Creating Data Types from Scratch](#chapter6part2.5)
      - [Chapter 6 - Part 2.6: Creating Data Types from Other Data Types](#chapter6part2.6)
    - [Chapter 6 - Part 3: Custom Collection Classes](#chapter6part3)
      - [Chapter 6 - Part 3.1: Creating Classes That Aggregate Collections](#chapter6part3.1)
      - [Chapter 6 - Part 3.2: Creating Collection Classes Using Aggregation](#chapter6part3.2)
      - [Chapter 6 - Part 3.3: Creating Collection Classes Using Inheritance](#chapter6part3.3)
7. [Chapter 7: File Handling](#chapter7)
    - [Chapter 7 - Part 1: Writing and Reading Binary Data](#chapter7part1)
      - [Chapter 7 - Part 1.1: Pickles with Optional Compression](#chapter7part1.1)
      - [Chapter 7 - Part 1.2: Raw Binary Data with Optional Compression](#chapter7part1.2)
    - [Chapter 7 - Part 2: Writing and Parsing Text Files](#chapter7part2)
      - [Chapter 7 - Part 2.1: Writing Text](#chapter7part2.1)
      - [Chapter 7 - Part 2.2: Parsing Text](#chapter7part2.2)
      - [Chapter 7 - Part 2.3: Parsing Text Using Regular Expressions](#chapter7part2.3)
    - [Chapter 7 - Part 3: Writing and Parsing XML Files](#chapter7part3)
      - [Chapter 7 - Part 3.1: Element Trees](#chapter7part3.1)
      - [Chapter 7 - Part 3.2: DOM (Document Object Model)](#chapter7part3.2)
      - [Chapter 7 - Part 3.3: Manually Writing XML](#chapter7part3.3)
      - [Chapter 7 - Part 3.4: Parsing XML with SAX (Simple API for XML)](#chapter7part3.4)
    - [Chapter 7 - Part 4: Random Access Binary Files](#chapter7part4)
      - [Chapter 7 - Part 4.1: A Generic BinaryRecordFile Class](#chapter7part4.1)
      
    
## <a name="chapter1"></a>Chapter 1: Rapid Introduction to Procedural Programming

#### <a name="chapter1part1"></a>Chapter 1 - Part 1: Creating and Running Python Programs

Python code can be written using any plain text editor that can load and save text using either the ASCII or the UTF-8 Unicode character encoding.

By default, Python files are assumed to use the UTF-8 character encoding, a superset of ASCII that can represent pretty well every character in every language. 

Python files normally have an extension of .py, although on some Unix-like systems (e.g., Linux and Mac OS X) some Python applications have no extension, and Python GUI (Graphical User Interface) programs usually have an extension of .pyw, particularly onWindows and Mac OSX.

Create a file called hello.py in a plain text editor with the following contents:

```py
#!/usr/bin/env python3

print("Hello", "World!")
```

The first line is a comment. In Python,commentsbegin with a # and continue to the end of the line.

The second line is blank—outside quoted strings, Python ignores blank lines, but they are often useful to humans to break up large blocks of code to make them easier to read.

The third line is Python code. Here, the print() function is called with two arguments, each of type str (string; i.e., a sequence of characters).

Each statement encountered in a .py file is executed in turn, starting with the first one and progressing line by line. This is different from some other languages, for example, C++ and Java, which have a particular function or method with a special name where they start from.

We will assume that Windows users keep their Python code in the C:\py3eg directory and that Unix (i.e., Unix, Linux, and Mac OS X) users keep their code in the $HOME/py3eg directory. Save hello.py into the py3eg directory and close the text editor.

Now that we have a program, we can run it. Python programs are executed by the Python interpreter, and normally this is done inside a console window.

On Windows the console is called "Command Prompt"

On Mac OS X the console is provided by the Terminal.app program (located in Applications/Utilities by default), available using Finder, and on other Unixes,we can use an xterm or the console provided by the windowing environment, for example, konsole or gnome-terminal.

Start up a console, and on Windows enter the following commands

```
C:\>cd c:\py3eg
C:\py3eg\>c:\python31\python.exe hello.py
```

Unix users enter this instead (assuming that Python 3 is in the PATH):*

```
$ cd $HOME/py3eg
$ python3 hello.py
```

In both cases the output should be the same:

```
Hello World!
```

Although the program has just one executable statement, by running it we can infer some information about the print() function. For one thing, print() is a built-in part of the Python language—we didn’t need to “import” or “include” it from a library to make use of it. Also, it separates each item it prints with a single space, and prints a newline after the last item is printed.

#### <a name="chapter1part2"></a>Chapter 1 - Part 2: Data Types in Python

In programming, data type is an important concept.

Variables can store data of different types, and different types can do different things.

Python has the following data types built-in by default, in these categories:

- Text Type: ```str```
- Numeric Types: ```int```, ```float```, ```complex```
- Sequence Types: ```list```, ```tuple```, ```range```
- Mapping Type: ```dict```
- Set Types: ```set```, ```frozenset```
- Boolean Type: ```bool```
- Binary Types: ```bytes```, ```bytearray```, ```memoryview```
- None Type: ```NoneType```

Python represents integers (positive and negative whole numbers) using the int type, and it represents strings (sequences of Unicode characters) using the str type.

**Integers Examples**

```
-973
210624583337114373395836055367340864637790190801098222508621955072
0
```

Incidentally, the second number shown is the size of Python’s integers is limited only by machine memory, not by a fixed number of bytes.

**Strings Examples**

```
"Infinitely Demanding"
'Simon Critchley'
'positively αβγ ÷©'
''
```

Strings can be delimited by double or single quotes, as long as the same kind are used at both ends, and since Python uses Unicode, strings are not limited to ASCII characters, as the penultimate string shows. An empty string is simply one with nothing between the delimiters.

Python uses square brackets ([]) to access an item from a sequence such as
a string.

```py
print("Hard Times"[5])
```

```
T
```

```py
print("giraffe"[0])
```

```
g
```

In Python, both str and the basic numeric types such as int are immutable, that is, once set, their value cannot be changed.

To convert a data item from one type to another we can use the syntax datatype(item).

```py
int("45")
```

```py
str(912)
```

The int() conversion is tolerant of leading and trailing whitespace, so int(" 45 ") would have worked just as well. The str() conversion can be
applied to almost any data item. We can easily make our own custom data types support str() conversion, and also int() or other conversions if they make sense.
If a conversion fails, an exception is raised

#### <a name="chapter1part3"></a>Chapter 1 - Part 3: Object References in Python

Python doesn’t have variables as such, but instead has object references.

When it comes to immutable objects like ints and strs, there is no discernable difference between a variable and an object reference.

As for mutable objects, there is a difference, but it rarely matters in practice.

Let’s look at a few tiny examples, and then discuss some of the details.

```py
x = "blue"
y = "green"
z = x
```

The syntax is simply objectReference = value.

When Python executes the first statement it creates a str object with the text “blue”, and creates an object reference called x that refers to the str object.

For all practical purposes we can say that “variable x has been assigned the ‘blue’ string”. The second statement is similar. The third statement creates a new object reference called z and sets it to refer to the same object that the x object reference refers to (in this case the str containing the text “blue”).

The = operator is not the same as the variable assignment operator in some other languages. The = operator binds an object reference to an object in memory. If the object reference already exists, it is simply re-bound to refer to the object on the right of the = operator if the object reference does not exist it is created by the = operator.

```py
print(x, y, z) # prints: blue green blue
z = y
print(x, y, z) # prints: blue green green
x = z
print(x, y, z) # prints: green green green
```

After the fourth statement (x = z), all three object references are referring to the same str. Since there are no more object references to the “blue” string, Python is free to garbage-collect it.

<br>

<div align="center"><img src="img/objectreference-w610-h640.png" width=610 height=640><br><sub>Object references and objects (The circles represent object references.The rectangles represent objects in memory.) - (<a href='https://github.com/vitorstabile'>Work by Vitor Garcia</a>) </sub></div>

<br>

The names used for object references (called identifiers) have a few restrictions. In particular, they may not be the same as any of Python’s keywords, and must start with a letter or an underscore and be followed by zero or more nonwhitespace letter, underscore, or digit characters. There is no length limit, and the letters and digits are those defined by Unicode, that is, they include, but are not limited to, ASCII’s letters and digits (“a”, “b”, …, “z”, “A”, “B”,…, “Z”, “0”, “1”, …, “9”). Python identifiers are case-sensitive, so for example, LIMIT, Limit, and limit are three different identifiers.

Python uses dynamic typing, which means that an object reference can be rebound to refer to a different object (which may be of a different data type) at any time. Languages that use strong typing (such as C++ and Java) allow only those operations that are defined for the data types involved to be performed. Python also applies this constraint, but it isn’t called strong typing in Python’s case because the valid operations can change—for example, if an object reference is re-bound to an object of a different data type.

```py
route = 866
print(route, type(route)) # prints: 866 <class 'int'>
```

```py
route = "North"
print(route, type(route)) # prints: North <class 'str'>
```

Here we create a new object reference called route and set it to refer to a new int of value 866. At this point we could use / with route since division is a valid operation for integers. Then we reuse the route object reference to refer to a new str of value “North”, and the int object is scheduled for garbage collection since now no object reference refers to it. At this point using / with route would cause a TypeError to be raised since / is not a valid operation for a string.

The type() function returns the data type (also known as the "class”) of the data item it is given—this function can be very useful for testing and debugging.

#### <a name="chapter1part4"></a>Chapter 1 - Part 4: Collection Data Types in Python

There are four collection data types in the Python programming language:

- List: is a collection which is ordered and changeable. Allows duplicate members.
- Tuple: is a collection which is ordered and unchangeable. Allows duplicate members.
- Set: is a collection which is unordered, unchangeable*, and unindexed. No duplicate members.
- Dictionary: is a collection which is ordered** and changeable. No duplicate members.

But here we will introduce just two: tuple and list. Python tuples and lists can be used to hold any number of data items of any data types. Tuples are immutable, so once they are created we cannot change them. Lists are mutable, so we can easily insert items and remove items whenever we want.

Tuples are created using commas (,), as these examples show

```py
print("Denmark", "Finland", "Norway", "Sweden") # prints: ('Denmark', 'Finland', 'Norway', 'Sweden')
```

```py
print("one",) # prints: ('one',)
```

An empty tuple is created by using empty parentheses, (). The comma is also used to separate arguments in function calls, so if we want to pass a tuple literal as an argument we must enclose it in parentheses to avoid confusion.

Here are some example lists:

```py
print([1, 4, 9, 16, 25, 36, 49])
print(['alpha', 'bravo', 'charlie', 'delta', 'echo'])
print(['zebra', 49, -879, 'aardvark', 200])
print([])
```

One way to create a list is to use square brackets ([]). The fourth list shown is an empty list.

When lists and tuples are created (and when items are inserted in the case of lists), they take copies of the object references they are given. In the case of literal items such as integers or strings, an object of the appropriate
data type is created in memory and suitably initialized, and then an object reference referring to the object is created, and it is this object reference that is put in the list or tuple.

Tuples, lists, and strings are “sized”, that is, they are data types that have a notion of size, and data items of any such data type can be meaningfully passed to the len() function. (An exception is raised if a nonsized data item is passed to len().)

```py
len(("one",)) # 1
```

```py
len([3, 5, 1, 2, "pause", 5]) # 6
```

```py
len("automatically") # 13
```

All Python data items are objects (also called instances) of a particular data type (also called a class)

Essentially, a method is simply a function that is called for a particular object. For example, the list type has an append() method, so we can append an object to a list like this:

```py
x = ["zebra", 49, -879, "aardvark", 200]
x.append("more")
print(x) # ['zebra', 49, -879, 'aardvark', 200, 'more']
``` 

The append() method mutates, that is, changes, the original list. This is possible because lists are mutable.

The list type has many other methods, including insert() which is used to insert an item at a given index position,and remove() which removes an item at a given index position. As noted earlier, Python indexes are always 0-based.

```py
x = ['zebra', 49, -879, 'aardvark', 200, 'more', 'extra']
print(x[0]) # print: zebra
print(x[4]) # print: 200
```

Tuples are also sequences, so if x had been a tuple we could retrieve items using square brackets in exactly the same way aswe have done for the x list. But since lists are mutable (unlike strings and tuples which are immutable),we can also use the square brackets operator to set list elements.

```py
x = ['zebra', 49, -879, 'aardvark', 200, 'more', 'extra']
x[1] = "forty nine"
print(x) # print: ['zebra', 'forty nine', -879, 'aardvark', 200, 'more', 'extra']
```

#### <a name="chapter1part5"></a>Chapter 1 - Part 5: Logical Operations in Python

###### <a name="chapter1part5.1"></a>Chapter 1 - Part 5.1: The Identity Operator

###### <a name="chapter1part5.2"></a>Chapter 1 - Part 5.2: Comparison Operators

###### <a name="chapter1part5.3"></a>Chapter 1 - Part 5.3: The Membership Operator

###### <a name="chapter1part5.4"></a>Chapter 1 - Part 5.4: Logical Operators

#### <a name="chapter1part6"></a>Chapter 1 - Part 6: Control Flow Statements in Python

###### <a name="chapter1part6.1"></a>Chapter 1 - Part 6.1: The if Statement

###### <a name="chapter1part6.2"></a>Chapter 1 - Part 6.2: The while Statement

###### <a name="chapter1part6.3"></a>Chapter 1 - Part 6.3: The for …in Statement

###### <a name="chapter1part6.4"></a>Chapter 1 - Part 6.4: Basic Exception Handling

#### <a name="chapter1part7"></a>Chapter 1 - Part 7: Arithmetic Operators in Python

#### <a name="chapter1part8"></a>Chapter 1 - Part 8: Input/Output in Python

#### <a name="chapter1part9"></a>Chapter 1 - Part 9: Creating and Calling Functions in Python

## <a name="chapter2"></a>Chapter 2: Data Types

#### <a name="chapter2part1"></a>Chapter 2 - Part 1: Identifiers and Keywords

#### <a name="chapter2part2"></a>Chapter 2 - Part 2: Integral Types

###### <a name="chapter2part2.1"></a>Chapter 2 - Part 2.1: Integers

###### <a name="chapter2part2.2"></a>Chapter 2 - Part 2.2: Booleans

###### <a name="chapter2part2.3"></a>Chapter 2 - Part 2.3: Integer Bitwise Operators

#### <a name="chapter2part3"></a>Chapter 2 - Part 3: Floating-Point Types

###### <a name="chapter2part3.1"></a>Chapter 2 - Part 3.1: Floating-Point Numbers

###### <a name="chapter2part3.2"></a>Chapter 2 - Part 3.2: Complex Numbers

###### <a name="chapter2part3.3"></a>Chapter 2 - Part 3.3: Decimal Numbers

#### <a name="chapter2part4"></a>Chapter 2 - Part 4: Strings

###### <a name="chapter2part4.1"></a>Chapter 2 - Part 4.1: Comparing Strings

###### <a name="chapter2part4.2"></a>Chapter 2 - Part 4.2: Slicing and Striding Strings

###### <a name="chapter2part4.3"></a>Chapter 2 - Part 4.3: String Operators and Methods

###### <a name="chapter2part4.4"></a>Chapter 2 - Part 4.4: String Formatting with the str.format() Method

###### <a name="chapter2part4.5"></a>Chapter 2 - Part 4.5: Field Names

###### <a name="chapter2part4.6"></a>Chapter 2 - Part 4.6: Conversions

###### <a name="chapter2part4.7"></a>Chapter 2 - Part 4.7: Format Specifications

###### <a name="chapter2part4.8"></a>Chapter 2 - Part 4.8: Character Encodings

## <a name="chapter3"></a>Chapter 3: Collection Data Types

#### <a name="chapter3part1"></a>Chapter 3 - Part 1: Sequence Types

###### <a name="chapter3part1.1"></a>Chapter 3 - Part 1.1: Tuples

###### <a name="chapter3part1.2"></a>Chapter 3 - Part 1.2: Named Tuples

###### <a name="chapter3part1.3"></a>Chapter 3 - Part 1.3: Lists

###### <a name="chapter3part1.4"></a>Chapter 3 - Part 1.4: List Comprehensions

#### <a name="chapter3part2"></a>Chapter 3 - Part 2: Set Types

###### <a name="chapter3part2.1"></a>Chapter 3 - Part 2.1: Sets

###### <a name="chapter3part2.2"></a>Chapter 3 - Part 2.2: Set Comprehensions

###### <a name="chapter3part2.3"></a>Chapter 3 - Part 2.3: Frozen Sets

#### <a name="chapter3part3"></a>Chapter 3 - Part 3: Mapping Types

###### <a name="chapter3part3.1"></a>Chapter 3 - Part 3.1: Dictionaries

###### <a name="chapter3part3.2"></a>Chapter 3 - Part 3.2: Dictionary Comprehensions

###### <a name="chapter3part3.3"></a>Chapter 3 - Part 3.3: Default Dictionaries

###### <a name="chapter3part3.4"></a>Chapter 3 - Part 3.4: Ordered Dictionaries

#### <a name="chapter3part4"></a>Chapter 3 - Part 4: Iterating and Copying Collections

###### <a name="chapter3part4.1"></a>Chapter 3 - Part 4.1: Iterators and Iterable Operations and Functions

###### <a name="chapter3part4.2"></a>Chapter 3 - Part 4.2: Copying Collections

## <a name="chapter4"></a>Chapter 4: Control Structures and Functions

#### <a name="chapter4part1"></a>Chapter 4 - Part 1: Control Structures

###### <a name="chapter4part1.1"></a>Chapter 4 - Part 1.1: Conditional Branching

###### <a name="chapter4part1.2"></a>Chapter 4 - Part 1.2: Looping

###### <a name="chapter4part1.3"></a>Chapter 4 - Part 1.3: While Loops

###### <a name="chapter4part1.4"></a>Chapter 4 - Part 1.4: For Loops

#### <a name="chapter4part2"></a>Chapter 4 - Part 2: Exception Handling

###### <a name="chapter4part2.1"></a>Chapter 4 - Part 2.1: Catching and Raising Exceptions

###### <a name="chapter4part2.2"></a>Chapter 4 - Part 2.2: Raising Exceptions

###### <a name="chapter4part2.3"></a>Chapter 4 - Part 2.3: Custom Exceptions

#### <a name="chapter4part3"></a>Chapter 4 - Part 3: Custom Functions

###### <a name="chapter4part3.1"></a>Chapter 4 - Part 3.1: Names and Docstrings

###### <a name="chapter4part3.2"></a>Chapter 4 - Part 3.2: Argument and Parameter Unpacking

###### <a name="chapter4part3.3"></a>Chapter 4 - Part 3.3: Accessing Variables in the Global Scope

###### <a name="chapter4part3.4"></a>Chapter 4 - Part 3.4: Lambda Functions

###### <a name="chapter4part3.5"></a>Chapter 4 - Part 3.5: Assertions

## <a name="chapter5"></a>Chapter 5: Modules

#### <a name="chapter5part1"></a>Chapter 5 - Part 1: Modules and Packages

###### <a name="chapter5part1.1"></a>Chapter 5 - Part 1.1: Packages

###### <a name="chapter5part1.2"></a>Chapter 5 - Part 1.2: Custom Modules

###### <a name="chapter5part1.3"></a>Chapter 5 - Part 1.3: The TextUtil Module

###### <a name="chapter5part1.4"></a>Chapter 5 - Part 1.4: The CharGrid Module

#### <a name="chapter5part2"></a>Chapter 5 - Part 2: Overview of Python’s Standard Library

###### <a name="chapter5part2.1"></a>Chapter 5 - Part 2.1: String Handling

###### <a name="chapter5part2.2"></a>Chapter 5 - Part 2.2: Command-Line Programming

###### <a name="chapter5part2.3"></a>Chapter 5 - Part 2.3: Mathematics and Numbers

###### <a name="chapter5part2.4"></a>Chapter 5 - Part 2.4: Times and Dates

###### <a name="chapter5part2.5"></a>Chapter 5 - Part 2.5: Algorithms and Collection Data Types

###### <a name="chapter5part2.6"></a>Chapter 5 - Part 2.6: File Formats, Encodings, and Data Persistence

###### <a name="chapter5part2.7"></a>Chapter 5 - Part 2.7: File, Directory, and Process Handling

###### <a name="chapter5part2.8"></a>Chapter 5 - Part 2.8: Networking and Internet Programming

###### <a name="chapter5part2.9"></a>Chapter 5 - Part 2.9: XML

###### <a name="chapter5part2.10"></a>Chapter 5 - Part 2.10: Other Modules

## <a name="chapter6"></a>Chapter 6: Object-Oriented Programming

#### <a name="chapter6part1"></a>Chapter 6 - Part 1: The Object-Oriented Approach

###### <a name="chapter6part1.1"></a>Chapter 6 - Part 1.1: Object-Oriented Concepts and Terminology

#### <a name="chapter6part2"></a>Chapter 6 - Part 2: Custom Classes

###### <a name="chapter6part2.1"></a>Chapter 6 - Part 2.1: Attributes and Methods

###### <a name="chapter6part2.2"></a>Chapter 6 - Part 2.2: Inheritance and Polymorphism

###### <a name="chapter6part2.3"></a>Chapter 6 - Part 2.3: Using Properties to Control Attribute Access

###### <a name="chapter6part2.4"></a>Chapter 6 - Part 2.4: Creating Complete Fully Integrated Data Types

###### <a name="chapter6part2.5"></a>Chapter 6 - Part 2.5: Creating Data Types from Scratch

###### <a name="chapter6part2.6"></a>Chapter 6 - Part 2.6: Creating Data Types from Other Data Types

#### <a name="chapter6part3"></a>Chapter 6 - Part 3: Custom Collection Classes

###### <a name="chapter6part3.1"></a>Chapter 6 - Part 3.1: Creating Classes That Aggregate Collections

###### <a name="chapter6part3.2"></a>Chapter 6 - Part 3.2: Creating Collection Classes Using Aggregation

###### <a name="chapter6part3.3"></a>Chapter 6 - Part 3.3: Creating Collection Classes Using Inheritance

## <a name="chapter7"></a>Chapter 7: File Handling

#### <a name="chapter7part1"></a>Chapter 7 - Part 1: Writing and Reading Binary Data

###### <a name="chapter7part1.1"></a>Chapter 7 - Part 1.1: Pickles with Optional Compression

###### <a name="chapter7part1.2"></a>Chapter 7 - Part 1.2: Raw Binary Data with Optional Compression

#### <a name="chapter7part2"></a>Chapter 7 - Part 2: Writing and Parsing Text Files

###### <a name="chapter7part2.1"></a>Chapter 7 - Part 2.1: Writing Text

###### <a name="chapter7part2.2"></a>Chapter 7 - Part 2.2: Parsing Text

###### <a name="chapter7part2.3"></a>Chapter 7 - Part 2.3: Parsing Text Using Regular Expressions

#### <a name="chapter7part3"></a>Chapter 7 - Part 3: Writing and Parsing XML Files

###### <a name="chapter7part3.1"></a>Chapter 7 - Part 3.1: Element Trees

###### <a name="chapter7part3.2"></a>Chapter 7 - Part 3.2: DOM (Document Object Model

###### <a name="chapter7part3.3"></a>Chapter 7 - Part 3.3: Manually Writing XML

###### <a name="chapter7part3.4"></a>Chapter 7 - Part 3.4: Parsing XML with SAX (Simple API for XML)

#### <a name="chapter7part4"></a>Chapter 7 - Part 4: Random Access Binary Files

###### <a name="chapter7part4.1"></a>Chapter 7 - Part 4.1: A Generic BinaryRecordFile Class
