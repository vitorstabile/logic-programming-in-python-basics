<h1 align="center"> Python </h1>

# Content

1. [Chapter 1: Rapid Introduction to Procedural Programming](#chapter1)
    - [Chapter 1 - Part 1: Creating and Running Python Programs](#chapter1part1)
    - [Chapter 1 - Part 2: Data Types in Python](#chapter1part2)
    - [Chapter 1 - Part 3: Object References in Python](#chapter1part3)
    - [Chapter 1 - Part 4: Collection Data Types in Python](#chapter1part4)
    - [Chapter 1 - Part 5: Logical Operations in Python](#chapter1part5)
      - [Chapter 1 - Part 5.1: The Identity Operator](#chapter1part5.1)
      - [Chapter 1 - Part 5.2: Comparison Operators](#chapter1part5.2)
      - [Chapter 1 - Part 5.3: The Membership Operator](#chapter1part5.3)
      - [Chapter 1 - Part 5.4: Logical Operators](#chapter1part5.4)
    - [Chapter 1 - Part 6: Control Flow Statements in Python](#chapter1part6)
      - [Chapter 1 - Part 6.1: The if Statement](#chapter1part6.1)
      - [Chapter 1 - Part 6.2: The while Statement](#chapter1part6.2)
      - [Chapter 1 - Part 6.3: The for …in Statement](#chapter1part6.3)
      - [Chapter 1 - Part 6.4: Basic Exception Handling](#chapter1part6.4)
    - [Chapter 1 - Part 7: Arithmetic Operators in Python](#chapter1part7)
    - [Chapter 1 - Part 8: Input/Output in Python](#chapter1part8)
    - [Chapter 1 - Part 9: Creating and Calling Functions in Python](#chapter1part9)
2. [Chapter 2: Data Types](#chapter2)
    - [Chapter 2 - Part 1: Identifiers and Keywords](#chapter2part1)
    - [Chapter 2 - Part 2: Integral Types](#chapter2part2)
      - [Chapter 2 - Part 2.1: Integers](#chapter2part2.1)
      - [Chapter 2 - Part 2.2: Booleans](#chapter2part2.2)
      - [Chapter 2 - Part 2.3: Integer Bitwise Operators](#chapter2part2.3)
    - [Chapter 2 - Part 3: Floating-Point Types](#chapter2part3)
      - [Chapter 2 - Part 3.1: Floating-Point Numbers](#chapter2part3.1)
      - [Chapter 2 - Part 3.2: Complex Numbers](#chapter2part3.2)
      - [Chapter 2 - Part 3.3: Decimal Numbers](#chapter2part3.3)
    - [Chapter 2 - Part 4: Strings](#chapter2part4)
      - [Chapter 2 - Part 4.1: Comparing Strings](#chapter2part4.1)
      - [Chapter 2 - Part 4.2: Slicing and Striding Strings](#chapter2part4.2)
      - [Chapter 2 - Part 4.3: String Operators and Methods](#chapter2part4.3)
      - [Chapter 2 - Part 4.4: String Formatting with the str.format() Method](#chapter2part4.4)
      - [Chapter 2 - Part 4.5: Field Names](#chapter2part4.5)
3. [Chapter 3: Collection Data Types](#chapter3)
    - [Chapter 3 - Part 1: Sequence Types](#chapter3part1)
      - [Chapter 3 - Part 1.1: Tuples](#chapter3part1.1)
      - [Chapter 3 - Part 1.2: Named Tuples](#chapter3part1.2)
      - [Chapter 3 - Part 1.3: Lists](#chapter3part1.3)
      - [Chapter 3 - Part 1.4: List Comprehensions](#chapter3part1.4)
    - [Chapter 3 - Part 2: Set Types](#chapter3part2)
      - [Chapter 3 - Part 2.1: Sets](#chapter3part2.1)
      - [Chapter 3 - Part 2.2: Set Comprehensions](#chapter3part2.2)
      - [Chapter 3 - Part 2.3: Frozen Sets](#chapter3part2.3) 
    - [Chapter 3 - Part 3: Mapping Types](#chapter3part3)
      - [Chapter 3 - Part 3.1: Dictionaries](#chapter3part3.1)
      - [Chapter 3 - Part 3.2: Dictionary Comprehensions](#chapter3part3.2)
      - [Chapter 3 - Part 3.3: Default Dictionaries](#chapter3part3.3)
      - [Chapter 3 - Part 3.4: Ordered Dictionaries](#chapter3part3.4)
    - [Chapter 3 - Part 4: Iterating and Copying Collections](#chapter3part4)
      - [Chapter 3 - Part 4.1: Iterators and Iterable Operations and Functions](#chapter3part4.1)
      - [Chapter 3 - Part 4.2: Copying Collections](#chapter3part4.2)
4. [Chapter 4: Control Structures and Functions](#chapter4)
    - [Chapter 4 - Part 1: Control Structures](#chapter4part1)
      - [Chapter 4 - Part 1.1: Conditional Branching](#chapter4part1.1)
      - [Chapter 4 - Part 1.2: Looping](#chapter4part1.2)
      - [Chapter 4 - Part 1.3: While Loops](#chapter4part1.3)
      - [Chapter 4 - Part 1.4: For Loops](#chapter4part1.4)
    - [Chapter 4 - Part 2: Exception Handling](#chapter4part2)
      - [Chapter 4 - Part 2.1: Catching and Raising Exceptions](#chapter4part2.1)
      - [Chapter 4 - Part 2.2: Raising Exceptions](#chapter4part2.2)
      - [Chapter 4 - Part 2.3: Custom Exceptions](#chapter4part2.3)
    - [Chapter 4 - Part 3: Custom Functions](#chapter4part3)
      - [Chapter 4 - Part 3.1: Names and Docstrings](#chapter4part3.1)
      - [Chapter 4 - Part 3.2: Argument and Parameter Unpacking](#chapter4part3.2)
      - [Chapter 4 - Part 3.3: Accessing Variables in the Global Scope](#chapter4part3.3)
      - [Chapter 4 - Part 3.4: Lambda Functions](#chapter4part3.4)
      - [Chapter 4 - Part 3.5: Assertions](#chapter4part3.5)
5. [Chapter 5: Modules](#chapter5)
    - [Chapter 5 - Part 1: Modules and Packages](#chapter5part1)
      - [Chapter 5 - Part 1.1: Packages](#chapter5part1.1)
      - [Chapter 5 - Part 1.2: Custom Modules](#chapter5part1.2)
      - [Chapter 5 - Part 1.3: The TextUtil Module](#chapter5part1.3)
      - [Chapter 5 - Part 1.4: The CharGrid Module](#chapter5part1.4)
    - [Chapter 5 - Part 2: Overview of Python’s Standard Library](#chapter5part2)
      - [Chapter 5 - Part 2.1: String Handling](#chapter5part2.1)
      - [Chapter 5 - Part 2.2: Command-Line Programming](#chapter5part2.2)
      - [Chapter 5 - Part 2.3: Mathematics and Numbers](#chapter5part2.3)
      - [Chapter 5 - Part 2.4: Times and Dates](#chapter5part2.4)
      - [Chapter 5 - Part 2.5: Algorithms and Collection Data Types](#chapter5part2.5)
      - [Chapter 5 - Part 2.6: File Formats, Encodings, and Data Persistence](#chapter5part2.6)
      - [Chapter 5 - Part 2.7: File, Directory, and Process Handling](#chapter5part2.7)
      - [Chapter 5 - Part 2.8: Networking and Internet Programming](#chapter5part2.8)
      - [Chapter 5 - Part 2.9: XML](#chapter5part2.9)
      - [Chapter 5 - Part 2.10: Other Modules](#chapter5part2.10)  
6. [Chapter 6: Object-Oriented Programming](#chapter6)
    - [Chapter 6 - Part 1: The Object-Oriented Approach](#chapter6part1)
      - [Chapter 6 - Part 1.1: Object-Oriented Concepts and Terminology](#chapter6part1.1)
    - [Chapter 6 - Part 2: Custom Classes](#chapter6part2)
      - [Chapter 6 - Part 2.1: Attributes and Methods](#chapter6part2.1)
      - [Chapter 6 - Part 2.2: Inheritance and Polymorphism](#chapter6part2.2)
      - [Chapter 6 - Part 2.3: Using Properties to Control Attribute Access](#chapter6part2.3)
      - [Chapter 6 - Part 2.4: Creating Complete Fully Integrated Data Types](#chapter6part2.4)
      - [Chapter 6 - Part 2.5: Creating Data Types from Scratch](#chapter6part2.5)
      - [Chapter 6 - Part 2.6: Creating Data Types from Other Data Types](#chapter6part2.6)
    - [Chapter 6 - Part 3: Custom Collection Classes](#chapter6part3)
      - [Chapter 6 - Part 3.1: Creating Classes That Aggregate Collections](#chapter6part3.1)
      - [Chapter 6 - Part 3.2: Creating Collection Classes Using Aggregation](#chapter6part3.2)
      - [Chapter 6 - Part 3.3: Creating Collection Classes Using Inheritance](#chapter6part3.3)
7. [Chapter 7: File Handling](#chapter7)
    - [Chapter 7 - Part 1: Writing and Reading Binary Data](#chapter7part1)
      - [Chapter 7 - Part 1.1: Pickles with Optional Compression](#chapter7part1.1)
      - [Chapter 7 - Part 1.2: Raw Binary Data with Optional Compression](#chapter7part1.2)
    - [Chapter 7 - Part 2: Writing and Parsing Text Files](#chapter7part2)
      - [Chapter 7 - Part 2.1: Writing Text](#chapter7part2.1)
      - [Chapter 7 - Part 2.2: Parsing Text](#chapter7part2.2)
      - [Chapter 7 - Part 2.3: Parsing Text Using Regular Expressions](#chapter7part2.3)
    - [Chapter 7 - Part 3: Writing and Parsing XML Files](#chapter7part3)
      - [Chapter 7 - Part 3.1: Element Trees](#chapter7part3.1)
      - [Chapter 7 - Part 3.2: DOM (Document Object Model)](#chapter7part3.2)
      - [Chapter 7 - Part 3.3: Manually Writing XML](#chapter7part3.3)
      - [Chapter 7 - Part 3.4: Parsing XML with SAX (Simple API for XML)](#chapter7part3.4)
    - [Chapter 7 - Part 4: Random Access Binary Files](#chapter7part4)
      - [Chapter 7 - Part 4.1: A Generic BinaryRecordFile Class](#chapter7part4.1)
8. [Chapter 8: Useful Python Code Snippet](#chapter8)
    - [Chapter 8 - Part 1: Create a Log file](#chapter8part1)
    - [Chapter 8 - Part 2: List all files of a directory based in a extension](#chapter8part2)
    - [Chapter 8 - Part 3: List all files of a directory based in a regex](#chapter8part3)
    - [Chapter 8 - Part 4: Move file to a directory](#chapter8part4)
    - [Chapter 8 - Part 5: Read a Config Json File](#chapter8part5)
    - [Chapter 8 - Part 6: Read and Parse a CSV file with Pandas based in a Config Json File](#chapter8part6)
    
## <a name="chapter1"></a>Chapter 1: Rapid Introduction to Procedural Programming

#### <a name="chapter1part1"></a>Chapter 1 - Part 1: Creating and Running Python Programs

Python code can be written using any plain text editor that can load and save text using either the ASCII or the UTF-8 Unicode character encoding.

By default, Python files are assumed to use the UTF-8 character encoding, a superset of ASCII that can represent pretty well every character in every language. 

Python files normally have an extension of .py, although on some Unix-like systems (e.g., Linux and Mac OS X) some Python applications have no extension, and Python GUI (Graphical User Interface) programs usually have an extension of .pyw, particularly onWindows and Mac OSX.

Create a file called hello.py in a plain text editor with the following contents:

```py
#!/usr/bin/env python3

print("Hello", "World!")
```

The first line is a comment. In Python,commentsbegin with a # and continue to the end of the line.

The second line is blank—outside quoted strings, Python ignores blank lines, but they are often useful to humans to break up large blocks of code to make them easier to read.

The third line is Python code. Here, the print() function is called with two arguments, each of type str (string; i.e., a sequence of characters).

Each statement encountered in a .py file is executed in turn, starting with the first one and progressing line by line. This is different from some other languages, for example, C++ and Java, which have a particular function or method with a special name where they start from.

We will assume that Windows users keep their Python code in the C:\py3eg directory and that Unix (i.e., Unix, Linux, and Mac OS X) users keep their code in the $HOME/py3eg directory. Save hello.py into the py3eg directory and close the text editor.

Now that we have a program, we can run it. Python programs are executed by the Python interpreter, and normally this is done inside a console window.

On Windows the console is called "Command Prompt"

On Mac OS X the console is provided by the Terminal.app program (located in Applications/Utilities by default), available using Finder, and on other Unixes,we can use an xterm or the console provided by the windowing environment, for example, konsole or gnome-terminal.

Start up a console, and on Windows enter the following commands

```
C:\>cd c:\py3eg
C:\py3eg\>c:\python31\python.exe hello.py
```

Unix users enter this instead (assuming that Python 3 is in the PATH):*

```
$ cd $HOME/py3eg
$ python3 hello.py
```

In both cases the output should be the same:

```
Hello World!
```

Although the program has just one executable statement, by running it we can infer some information about the print() function. For one thing, print() is a built-in part of the Python language—we didn’t need to “import” or “include” it from a library to make use of it. Also, it separates each item it prints with a single space, and prints a newline after the last item is printed.

#### <a name="chapter1part2"></a>Chapter 1 - Part 2: Data Types in Python

In programming, data type is an important concept.

Variables can store data of different types, and different types can do different things.

Python has the following data types built-in by default, in these categories:

- Text Type: ```str```
- Numeric Types: ```int```, ```float```, ```complex```
- Sequence Types: ```list```, ```tuple```, ```range```
- Mapping Type: ```dict```
- Set Types: ```set```, ```frozenset```
- Boolean Type: ```bool```
- Binary Types: ```bytes```, ```bytearray```, ```memoryview```
- None Type: ```NoneType```

Python represents integers (positive and negative whole numbers) using the int type, and it represents strings (sequences of Unicode characters) using the str type.

**Integers Examples**

```
-973
210624583337114373395836055367340864637790190801098222508621955072
0
```

Incidentally, the second number shown is the size of Python’s integers is limited only by machine memory, not by a fixed number of bytes.

**Strings Examples**

```
"Infinitely Demanding"
'Simon Critchley'
'positively αβγ ÷©'
''
```

Strings can be delimited by double or single quotes, as long as the same kind are used at both ends, and since Python uses Unicode, strings are not limited to ASCII characters, as the penultimate string shows. An empty string is simply one with nothing between the delimiters.

Python uses square brackets ([]) to access an item from a sequence such as
a string.

```py
print("Hard Times"[5])
```

```
T
```

```py
print("giraffe"[0])
```

```
g
```

In Python, both str and the basic numeric types such as int are immutable, that is, once set, their value cannot be changed.

To convert a data item from one type to another we can use the syntax datatype(item).

```py
int("45")
```

```py
str(912)
```

The int() conversion is tolerant of leading and trailing whitespace, so int(" 45 ") would have worked just as well. The str() conversion can be
applied to almost any data item. We can easily make our own custom data types support str() conversion, and also int() or other conversions if they make sense.
If a conversion fails, an exception is raised

#### <a name="chapter1part3"></a>Chapter 1 - Part 3: Object References in Python

Python doesn’t have variables as such, but instead has object references.

When it comes to immutable objects like ints and strs, there is no discernable difference between a variable and an object reference.

As for mutable objects, there is a difference, but it rarely matters in practice.

Let’s look at a few tiny examples, and then discuss some of the details.

```py
x = "blue"
y = "green"
z = x
```

The syntax is simply objectReference = value.

When Python executes the first statement it creates a str object with the text “blue”, and creates an object reference called x that refers to the str object.

For all practical purposes we can say that “variable x has been assigned the ‘blue’ string”. The second statement is similar. The third statement creates a new object reference called z and sets it to refer to the same object that the x object reference refers to (in this case the str containing the text “blue”).

The = operator is not the same as the variable assignment operator in some other languages. The = operator binds an object reference to an object in memory. If the object reference already exists, it is simply re-bound to refer to the object on the right of the = operator if the object reference does not exist it is created by the = operator.

```py
print(x, y, z) # prints: blue green blue
z = y
print(x, y, z) # prints: blue green green
x = z
print(x, y, z) # prints: green green green
```

After the fourth statement (x = z), all three object references are referring to the same str. Since there are no more object references to the “blue” string, Python is free to garbage-collect it.

<br>

<div align="center"><img src="img/objectreference-w610-h640.png" width=610 height=640><br><sub>Object references and objects (The circles represent object references.The rectangles represent objects in memory.) - (<a href='https://github.com/vitorstabile'>Work by Vitor Garcia</a>) </sub></div>

<br>

The names used for object references (called identifiers) have a few restrictions. In particular, they may not be the same as any of Python’s keywords, and must start with a letter or an underscore and be followed by zero or more nonwhitespace letter, underscore, or digit characters. There is no length limit, and the letters and digits are those defined by Unicode, that is, they include, but are not limited to, ASCII’s letters and digits (“a”, “b”, …, “z”, “A”, “B”,…, “Z”, “0”, “1”, …, “9”). Python identifiers are case-sensitive, so for example, LIMIT, Limit, and limit are three different identifiers.

Python uses dynamic typing, which means that an object reference can be rebound to refer to a different object (which may be of a different data type) at any time. Languages that use strong typing (such as C++ and Java) allow only those operations that are defined for the data types involved to be performed. Python also applies this constraint, but it isn’t called strong typing in Python’s case because the valid operations can change—for example, if an object reference is re-bound to an object of a different data type.

```py
route = 866
print(route, type(route)) # prints: 866 <class 'int'>
```

```py
route = "North"
print(route, type(route)) # prints: North <class 'str'>
```

Here we create a new object reference called route and set it to refer to a new int of value 866. At this point we could use / with route since division is a valid operation for integers. Then we reuse the route object reference to refer to a new str of value “North”, and the int object is scheduled for garbage collection since now no object reference refers to it. At this point using / with route would cause a TypeError to be raised since / is not a valid operation for a string.

The type() function returns the data type (also known as the "class”) of the data item it is given—this function can be very useful for testing and debugging.

#### <a name="chapter1part4"></a>Chapter 1 - Part 4: Collection Data Types in Python

There are four collection data types in the Python programming language:

- List: is a collection which is ordered and changeable. Allows duplicate members.
- Tuple: is a collection which is ordered and unchangeable. Allows duplicate members.
- Set: is a collection which is unordered, unchangeable*, and unindexed. No duplicate members.
- Dictionary: is a collection which is ordered** and changeable. No duplicate members.

But here we will introduce just two: tuple and list. Python tuples and lists can be used to hold any number of data items of any data types. Tuples are immutable, so once they are created we cannot change them. Lists are mutable, so we can easily insert items and remove items whenever we want.

Tuples are created using commas (,), as these examples show

```py
print("Denmark", "Finland", "Norway", "Sweden") # prints: ('Denmark', 'Finland', 'Norway', 'Sweden')
```

```py
print("one",) # prints: ('one',)
```

An empty tuple is created by using empty parentheses, (). The comma is also used to separate arguments in function calls, so if we want to pass a tuple literal as an argument we must enclose it in parentheses to avoid confusion.

Here are some example lists:

```py
print([1, 4, 9, 16, 25, 36, 49])
print(['alpha', 'bravo', 'charlie', 'delta', 'echo'])
print(['zebra', 49, -879, 'aardvark', 200])
print([])
```

One way to create a list is to use square brackets ([]). The fourth list shown is an empty list.

When lists and tuples are created (and when items are inserted in the case of lists), they take copies of the object references they are given. In the case of literal items such as integers or strings, an object of the appropriate
data type is created in memory and suitably initialized, and then an object reference referring to the object is created, and it is this object reference that is put in the list or tuple.

Tuples, lists, and strings are “sized”, that is, they are data types that have a notion of size, and data items of any such data type can be meaningfully passed to the len() function. (An exception is raised if a nonsized data item is passed to len().)

```py
len(("one",)) # 1
```

```py
len([3, 5, 1, 2, "pause", 5]) # 6
```

```py
len("automatically") # 13
```

All Python data items are objects (also called instances) of a particular data type (also called a class)

Essentially, a method is simply a function that is called for a particular object. For example, the list type has an append() method, so we can append an object to a list like this:

```py
x = ["zebra", 49, -879, "aardvark", 200]
x.append("more")
print(x) # ['zebra', 49, -879, 'aardvark', 200, 'more']
``` 

The append() method mutates, that is, changes, the original list. This is possible because lists are mutable.

The list type has many other methods, including insert() which is used to insert an item at a given index position,and remove() which removes an item at a given index position. As noted earlier, Python indexes are always 0-based.

```py
x = ['zebra', 49, -879, 'aardvark', 200, 'more', 'extra']
print(x[0]) # print: zebra
print(x[4]) # print: 200
```

Tuples are also sequences, so if x had been a tuple we could retrieve items using square brackets in exactly the same way aswe have done for the x list. But since lists are mutable (unlike strings and tuples which are immutable),we can also use the square brackets operator to set list elements.

```py
x = ['zebra', 49, -879, 'aardvark', 200, 'more', 'extra']
x[1] = "forty nine"
print(x) # print: ['zebra', 'forty nine', -879, 'aardvark', 200, 'more', 'extra']
```

#### <a name="chapter1part5"></a>Chapter 1 - Part 5: Logical Operations in Python

###### <a name="chapter1part5.1"></a>Chapter 1 - Part 5.1: The Identity Operator

The is operator is a binary operator that returns True if its left-hand object reference is referring to the same object as its right-hand object reference.

```py
a = ["Retention", 3, None]
b = ["Retention", 3, None]
print(a is b) # print: False
b = a
print(a is b) # print: True
```

One benefit of identity comparisons is that they are very fast. This is because the objects referred to do not have to be examined themselves. The is operator needs to compare only the memory addresses of the objects—the same address means the same object.

The most common use case for is is to compare a data item with the built-in null object, None, which is often used as a place-marking value to signify “unknown” or “nonexistent”:

```py
a = "Something"
b = None
print(a is not None, b is None) # print: (True, True)
```

To invert the identity test we use ```is not```.

###### <a name="chapter1part5.2"></a>Chapter 1 - Part 5.2: Comparison Operators

- ```<``` less than
- ```<=``` less than or equal to,
- ```==``` equal to
- ```!=``` not equal
- ```>=``` greater than or equal to
- ```>``` greater than

```py
a = 2
b = 6
print(a == b) # print: False
print(a < b) # print: True
print(a <= b, a != b, a >= b, a > b) # print: (True, True, False, False)
```

```py
a = ["many paths"]
b = ["many paths"]
print(a is b) # print: False
print(a == b) # print: True
```

The moral of this is to use == and != when comparing values, and to use ```is``` and ```is not``` only when comparing with ```None``` or when we really do want to see if two object references, rather than their values, are the same.

###### <a name="chapter1part5.3"></a>Chapter 1 - Part 5.3: The Membership Operator

For data types that are sequences or collections such as strings, lists, and tuples, we can test for membership using the ```in``` operator,and for nonmembership using the ```not in``` operator.

```py
p = (4, "frog", 9, -33, 9, 2)
print(2 in p) # print: True
print("dog" not in p) # print: True
```

```py
phrase = "Wild Swans by Jung Chang"
print("J" in phrase) # print: True
print("han" in phrase) # print: True
```

###### <a name="chapter1part5.4"></a>Chapter 1 - Part 5.4: Logical Operators

Python provides three logical operators: ```and```, ```or```, and ```not```. Both ```and``` and ```or``` use short-circuit logic and return the operand that determined the result—they do not return a Boolean (unless they actually have Boolean operands).

```py
five = 5
two = 2
zero = 0
print(five and two) # print: 2
print(two and five) # print: 5 
print(five and zero) # print: 0
```

If the expression occurs in a Boolean context, the result is evaluated as a Boolean, so the preceding expressions would come out as ```True```, ```True```, and ```False``` in, say, an ```if``` statement.

```py
nought = 0
five = 5
two = 2
zero = 0
print(five or two) # print: 5
print(two or five) # print: 2
print(zero or five) # print: 5
print(zero or nought) # print: 0
```

The ```or``` operator is similar; here the results in a Boolean context would be ```True```, ```True```, ```True```, and ```False```.

The ```not``` unary operator evaluates its argument in a Boolean context and always returns a Boolean result, so to continue the earlier example, ```not (zero or nought)``` would produce ```True```, and ```not two``` would produce ```False```.

#### <a name="chapter1part6"></a>Chapter 1 - Part 6: Control Flow Statements in Python

###### <a name="chapter1part6.1"></a>Chapter 1 - Part 6.1: The if Statement

The general syntax for Python’s if statement is this:

```
if boolean_expression1:
    suite1
elif boolean_expression2:
    suite2
...
elif boolean_expressionN:
    suiteN
else:
    else_suite
```

There can be zero or more ```elif``` clauses, and the final ```else``` clause is optional. If we want to account for a particular case, but want to do nothing if it occurs,we can use ```pass``` as that branch’s suite.

Unlike most other programming languages, Python uses indentation to signify its block structure. The Python style guidelines recommend four spaces per level of indentation, and only spaces (no tabs).

```py
if x:
    print("x is nonzero")
```

```py
if lines < 1000:
    print("small")
elif lines < 10000:
    print("medium")
else:
    print("large")
```

###### <a name="chapter1part6.2"></a>Chapter 1 - Part 6.2: The while Statement

The ```while``` statement is used to execute a suite zero or more times, the number of times depending on the state of the ```while``` loop’s Boolean expression.

```
while boolean_expression:
    suite
```

The ```break``` statement switches control to the statement following the innermost loop in which the break statement appears—that is, it breaks out of the loop. The ```continue``` statement switches control to the start of the loop. Both ```break``` and ```continue``` are normally used inside if statements to conditionally change a loop’s behavior.

```py
while True:
    item = get_next_item()
    if not item:
        break
    process_item(item)
```

###### <a name="chapter1part6.3"></a>Chapter 1 - Part 6.3: The for …in Statement

Python’s ```for``` loop reuses the ```in``` keyword (which in other contexts is the membership operator), and has the following syntax:

```
for variable in iterable:
    suite
```

Just like the ```while``` loop, the ```for``` loop supports both ```break``` and ```continue```, and also has an optional ```else``` clause.

The ```variable``` is set to refer to each object in the ```iterable``` in turn. An ```iterable``` is any data type that can be iterated over, and includes strings (where the iteration is character by character), lists, tuples, and Python’s other collection data types.

```py
for country in ["Denmark", "Finland", "Norway", "Sweden"]:
    print(country)
```

```py
for letter in "ABCDEFGHIJKLMNOPQRSTUVWXYZ":
    if letter in "AEIOU":
        print(letter, "is a vowel")
    else:
        print(letter, "is a consonant")
```

In this snippet the first use of the ```in``` keyword is part of a ```for``` statement, with the variable ```letter``` taking on the values "A", "B", and so on up to "Z", changing at each iteration of the loop. On the snippet’s second line we use ```in``` again, but this time as the membership testing operator.

```
('A', 'is a vowel')
('B', 'is a consonant')
('C', 'is a consonant')
('D', 'is a consonant')
('E', 'is a vowel')
('F', 'is a consonant')
('G', 'is a consonant')
('H', 'is a consonant')
('I', 'is a vowel')
('J', 'is a consonant')
('K', 'is a consonant')
('L', 'is a consonant')
('M', 'is a consonant')
('N', 'is a consonant')
('O', 'is a vowel')
('P', 'is a consonant')
('Q', 'is a consonant')
('R', 'is a consonant')
('S', 'is a consonant')
('T', 'is a consonant')
('U', 'is a vowel')
('V', 'is a consonant')
('W', 'is a consonant')
('X', 'is a consonant')
('Y', 'is a consonant')
('Z', 'is a consonant')
```

###### <a name="chapter1part6.4"></a>Chapter 1 - Part 6.4: Basic Exception Handling

Many of Python’s functions and methods indicate errors or other important events by raising an exception. An exception is an object like any other Python object, and when converted to a string (e.g., when printed), the exception produces a message text.

```
try:
    try_suite
except exception1 as variable1:
    exception_suite1
…
except exceptionN as variableN:
    exception_suiteN
```

Note that the ```as variable``` part is optional; we may care only that a particular exception was raised and not be interested in its message text.

The logic works like this. If the statements in the ```try``` block’s suite all execute without raising an exception, the except blocks are skipped. If an exception is raised inside the ```try``` block, control is immediately passed to the suite corresponding to the first matching ```exception```—this means that any statements in the suite that follow the one that caused the exception will not be executed. If this occurs and if the ```as variable``` part is given, then inside the exception-handling suite, ```variable``` refers to the exception object.

If an exception occurs in the handling ```except``` block, or if an exception is raised that does not match any of the ```except``` blocks in the first place, Python looks for a matching ```except``` block in the next enclosing scope. The search for a suitable exception handler works outward in scope and up the call stack until either a match is found and the exception is handled, or no match is found, in which case the program terminates with an unhandled exception. In the case of an unhandled exception, Python prints a traceback as well as the exception’s message text.

```py
s = input("enter an integer: ")
try:
    i = int(s)
    print("valid integer entered:", i)
except ValueError as err:
    print(err)
```

If the user enters “3.5”, the output will be:

```
invalid literal for int() with base 10: '3.5'
```

But if they were to enter “13”, the output will be:

```
valid integer entered: 13
```

#### <a name="chapter1part7"></a>Chapter 1 - Part 7: Arithmetic Operators in Python

Python provides a full set of arithmetic operators, including binary operators for the four basic mathematical operations:```+ addition```, ```- subtraction```,```* multiplication```, and ```/ division```. In addition, many Python data types can be used with augmented assignment operators such as ```+=``` and ```*=```. The ```+```, ```-```, and ```*``` operators all behave as expected when both of their operands are integers:

```py
print(5+6) # print: 11
```

```py
print(3-7) # print: -4
```

```py
print(4*8) # print: 32
```

The division operator produces a floating-point value, not an integer; many other languages will produce an integer, truncating any fractional part. If we need an integer result, we can always convert using ```int()``` (or use the truncating division operator ```//```.

```py
print(12/3) # print: 4.0
```

```py
print(3/2) # print: 1.5
```

```py
a = 5
print(a) # print: 5
a += 8
print(a) # print: 13
```

The first point to remember is that the int data type is immutable—that is, once assigned, an int’s value cannot be changed. So, what actually happens behind the scenes when an augmented assignment operator is used on an immutable object is that the operation is performed, and an object holding the result is created; and then the target object reference is re-bound to refer to the result object rather than the object it referred to before. So, in the preceding case when the statement a += 8 is encountered, Python computes a + 8, stores the result in a new int object, and then rebinds a to refer to this new int. (And if the original object a was referring to has no more object references referring to it, it will be scheduled for garbage collection.) Figure 1.3 illustrates this point.

Python overloads (i.e., reuses for a different data type) the + and += operators for both strings and lists, the former meaning concatenation and the latter meaning append for strings and extend (append another list) for lists:

```py
name = "John"
print(name + "Doe") # print: 'JohnDoe'
name += " Doe"
print(name) # print: 'John Doe'
```

Like integers, strings are immutable, so when += is used a new string is created and the expression’s left-hand object reference is re-bound to it, exactly as described earlier for ints.

Lists support the same syntax but are different behind the scenes:

```py
seeds = ["sesame", "sunflower"]
seeds += ["pumpkin"]
print(seeds) # print: ['sesame', 'sunflower', 'pumpkin']
```

Since lists are mutable, when += is used the original list object is modified, so no rebinding of seeds is necessary.

The right-hand operand for the list += operator must be an iterable; if it is not an exception is raised:

```py
seeds += 5
```

```
Traceback (most recent call last):
...
TypeError: 'int' object is not iterable
```

The correct way to extend a list is to use an iterable object, such as a list:

```py
seeds += [5]
print(seeds) # print: ['sesame', 'sunflower', 'pumpkin', 5]

And of course, the iterable object used to extend the list can itself have more than one item:

```py
seeds += [9, 1, 5, "poppy"]
print(seeds) # print: ['sesame', 'sunflower', 'pumpkin', 5, 9, 1, 5, 'poppy'] 
```

Appending a plain string—for example, "durian"—rather than a list containing a string, ["durian"], leads to a logical but perhaps surprising result:

```py
seeds = ["sesame", "sunflower", "pumpkin"]
seeds += "durian"
print(seeds) # print: ['sesame', 'sunflower', 'pumpkin', 'd', 'u', 'r', 'i', 'a', 'n']
```

The list += operator extends the list by appending each item of the iterable it is provided with; and since a string is an iterable, this leads to each character in the string being appended individually. If we use the list append() method, the argument is always added as a single item.

#### <a name="chapter1part8"></a>Chapter 1 - Part 8: Input/Output in Python

Python provides the built-in ```input()``` function to accept input from the user. This function takes an optional string argument (which it prints on the console); it then waits for the user to type in a response and to finish by pressing ```Enter (or Return)```. If the user does not type any text but just presses Enter, the ```input()``` function returns an empty string; otherwise, it returns a string containing what the user typed, without any line terminator.

```py
print("Type integers, each followed by Enter; or just Enter to finish")
total = 0
count = 0
while True:
    try:
        line = input("integer: ")
        if line:
            try:
                number = int(line)
            except ValueError as err:
                break
                continue
            total += number
            count += 1
    except Exception:
        break

if count:
    print("count =", count, "total =", total, "mean =", total / count)
```

```
integer: 1
integer: 2
integer: 3
integer: 
('count =', 3, 'total =', 6, 'mean =', 2)
```

#### <a name="chapter1part9"></a>Chapter 1 - Part 9: Creating and Calling Functions in Python

Python provides a means of encapsulating suites as functions which can be parameterized by the arguments they
are passed. Here is the general syntax for creating a function:

```
def functionName(arguments):
    suite
```

The ```arguments``` are optional and multiple arguments must be comma-separated.
Every Python function has a return value; this defaults to ```None``` unlesswe return
from the function using the syntax ```return value```, in which case ```value``` is returned.
The return value can be just one value or a tuple of values. The return value can be ignored by the caller, in which case it is simply thrown away.

Note that ```def``` is a statement that works in a similar way to the assignment operator. When def is executed a function object is created and an object reference with the specified name is created and set to refer to the function object. Since functions are objects, they can be stored in collection data types and passed as arguments to other functions, as we will see in later chapters.

One frequent need when writing interactive console applications is to obtain an integer from the user. Here is a function that does just that:

```py
def get_int(msg):
    while True:
        try:
            i = int(input(msg))
            return i
        except ValueError as err:
            print(err)
```

This function takes one argument, ```msg```. Inside the ```while``` loop the user is prompted to enter an integer. If they enter something invalid a ```ValueError``` exception will be raised, the error message will be printed, and the loop will repeat. Once a valid integer is entered, it is returned to the caller. Here is how we would call it:

```py
age = get_int("enter your age: ")
```

A Python module is just a .py file that contains Python code, such as custom function and class (custom data type) definitions, and sometimes variables. To access the functionality in a module we must import it.

```py
import sys
```

Once a module has been imported, we can access any functions, classes, or variables that it contains. For example:

```py
print(sys.argv)
```

Let us look at just one example, the random module (in the standard library’s random.py file), which provides many useful functions:

```py
import random
x = random.randint(1, 6)
y = random.choice(["apple", "banana", "cherry", "durian"])
```

## <a name="chapter2"></a>Chapter 2: Data Types

Python Data types are the classification or categorization of data items. It represents the kind of value that tells what operations can be performed on a particular data. Since everything is an object in Python programming, Python data types are classes and variables are instances (objects) of these classes. The following are the standard or built-in data types in Python:

<br>

<div align="center"><img src="img/pythondatatype-w822-h505.png" width=822 height=505><br><sub>Python Data Types - (<a href='https://www.geeksforgeeks.org/python-data-types/'>Work by Geeks for Geeks</a>) </sub></div>

<br>

- Text Type: ```str```
- Numeric Types: ```int```, ```float```, ```complex```
- Sequence Types: ```list```, ```tuple```, ```range```
- Mapping Type: ```dict```
- Set Types: ```set```, ```frozenset```
- Boolean Type: ```bool```
- Binary Types: ```bytes```, ```bytearray```, ```memoryview```
- None Type: ```NoneType```

To define the values ​​of various data types of Python and check their data types we use the ```type()``` function.

```py
route = 866
print(route, type(route)) # prints: 866 <class 'int'>
```

```py
route = "North"
print(route, type(route)) # prints: North <class 'str'>
```

#### <a name="chapter2part1"></a>Chapter 2 - Part 1: Identifiers and Keywords

The names we give to our object references are called ```identifiers``` or just ```plain names```.

Identifiers are case sensitive, so for example, ```TAXRATE```, ```Taxrate```, ```TaxRate```, ```taxRate```, and ```taxrate``` are five different identifiers.

The second rule is that no identifier can have the same name as one of Python’s keywords, so we cannot use any of the names shown bellow

| Keywords          | Description                                                                                                                                                 | 
| :---------------- | :----------------------------------------------------------------------------------------------------------------------------------------------------------:|
| and               | This is a logical operator which returns true if both the operands are true else returns false.                                                             |
| or                | This is also a logical operator which returns true if anyone operand is true else returns false.                                                            |             
| not               | This is again a logical operator it returns True if the operand is false else returns false.                                                                |
| if                | This is used to make a conditional statement.                                                                                                               |
| elif              | Elif is a condition statement used with an if statement. The elif statement is executed if the previous conditions were not true.                           |
| else              | Else is used with if and elif conditional statements. The else block is executed if the given condition is not true.                                        |
| for               | This is used to create a loop.                                                                                                                              |
| while             | This keyword is used to create a while loop.                                                                                                                |
| break             | This is used to terminate the loop.                                                                                                                         |
| as                | This is used to create an alternative.                                                                                                                      |
| def               | It helps us to define functions.                                                                                                                            |
| lambda            | It is used to define the anonymous function.                                                                                                                |
| pass              | This is a null statement which means it will do nothing.                                                                                                    |
| return            | It will return a value and exit the function.                                                                                                               |
| True              | This is a boolean value.                                                                                                                                    |
| False             | This is also a boolean value.                                                                                                                               |
| try               | It makes a try-except statement.                                                                                                                            |
| with              | The with keyword is used to simplify exception handling.                                                                                                    |
| assert            | This function is used for debugging purposes. Usually used to check the correctness of code                                                                 |
| class             | It helps us to define a class.                                                                                                                              |
| continue          | It continues to the next iteration of a loop                                                                                                                |
| del               | It deletes a reference to an object.                                                                                                                        |
| except            | Used with exceptions, what to do when an exception occurs                                                                                                   |
| finally           | Finally is used with exceptions, a block of code that will be executed no matter if there is an exception or not.                                           |
| from              | It is used to import specific parts of any module.                                                                                                          |
| global            | This declares a global variable.                                                                                                                            |
| import            | This is used to import a module.                                                                                                                            |
| in                | It’s used to check whether a value is present in a list, range, tuple, etc.                                                                                 |
| is                | This is used to check if the two variables are equal or not.                                                                                                |
| none              | This is a special constant used to denote a null value or avoid. It’s important to remember, 0, any empty container(e.g empty list) do not compute to None  |
| nonlocal          | It’s declared a non-local variable.                                                                                                                         |
| raise             | This raises an exception.                                                                                                                                   |
| yield             | It ends a function and returns a generator.                                                                                                                 |
| async             | It is used to create asynchronous coroutine.                                                                                                                |
| await             | It releases the flow of control back to the event loop.                                                                                                     |

The first convention is: Don’t use the names of any of Python’s predefined identifiers for your own identifiers. So, avoid using ```NotImplemented``` and ```Ellipsis```, and the name of any of Python’s built-in data types (such as ```int```, ```float```, ```list```, ```str```, and ```tuple```), and any of Python’s built-in functions or exceptions. How can we tell whether an identifier falls into one of these categories? Python has a built-in function called ```dir()``` that returns a list of an object’s attributes. If it is called with no arguments it returns the list of Python’s built-in attributes. For example:

```py
print(dir())
```

```
['__builtins__', '__doc__', '__file__', '__name__', '__package__']
```

The ```__builtins__``` attribute is, in effect, a module that holds all of Python’s built-in attributes. We can use it as an argument to the dir() function:

```py
print(dir(__builtins__))
```

```
['ArithmeticError', 'AssertionError', 'AttributeError', 'BaseException', 'BufferError', 'BytesWarning', 'DeprecationWarning', 'EOFError', 'Ellipsis', 'EnvironmentError', 'Exception', 'False', 'FloatingPointError', 'FutureWarning', 'GeneratorExit', 'IOError', 'ImportError', 'ImportWarning', 'IndentationError', 'IndexError', 'KeyError', 'KeyboardInterrupt', 'LookupError', 'MemoryError', 'NameError', 'None', 'NotImplemented', 'NotImplementedError', 'OSError', 'OverflowError', 'PendingDeprecationWarning', 'ReferenceError', 'RuntimeError', 'RuntimeWarning', 'StandardError', 'StopIteration', 'SyntaxError', 'SyntaxWarning', 'SystemError', 'SystemExit', 'TabError', 'True', 'TypeError', 'UnboundLocalError', 'UnicodeDecodeError', 'UnicodeEncodeError', 'UnicodeError', 'UnicodeTranslateError', 'UnicodeWarning', 'UserWarning', 'ValueError', 'Warning', 'WindowsError', 'ZeroDivisionError', '__debug__', '__doc__', '__import__', '__name__', '__package__', 'abs', 'all', 'any', 'apply', 'basestring', 'bin', 'bool', 'buffer', 'bytearray', 'bytes', 'callable', 'chr', 'classmethod', 'cmp', 'coerce', 'compile', 'complex', 'copyright', 'credits', 'delattr', 'dict', 'dir', 'divmod', 'enumerate', 'eval', 'execfile', 'exit', 'file', 'filter', 'float', 'format', 'frozenset', 'getattr', 'globals', 'hasattr', 'hash', 'help', 'hex', 'id', 'input', 'int', 'intern', 'isinstance', 'issubclass', 'iter', 'len', 'license', 'list', 'locals', 'long', 'map', 'max', 'memoryview', 'min', 'next', 'object', 'oct', 'open', 'ord', 'pow', 'print', 'property', 'quit', 'range', 'raw_input', 'reduce', 'reload', 'repr', 'reversed', 'round', 'set', 'setattr', 'slice', 'sorted', 'staticmethod', 'str', 'sum', 'super', 'tuple', 'type', 'unichr', 'unicode', 'vars', 'xrange', 'zip']
```

The second convention concerns the use of underscores (_). Names that begin and end with two underscores (such as ```__lt__```) should not be used. Python defines various special methods and variables that use such names

#### <a name="chapter2part2"></a>Chapter 2 - Part 2: Integral Types

Python provides two built-in integral types, ```int``` and ```bool```. Both integers and Booleans are immutable.

When used in Boolean expressions, ```0``` and ```False``` are ```False```, and any other ```integer``` and ```True``` are ```True```. When used in numerical expressions ```True``` evaluates to ```1``` and ```False``` to ```0```.

###### <a name="chapter2part2.1"></a>Chapter 2 - Part 2.1: Integers

The size of an integer is limited only by the machine’s memory.

Above, we can check the numeric operations

| Syntax        | Description                                                                                                                                                                            | 
| :------------ | :-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------:|
| x + y         | Adds number x and number y                                                                                                                                                             |
| x - y         | Subtracts y from x                                                                                                                                                                     |
| x * y         | Multiplies x by y                                                                                                                                                                      |
| x / y         | Divides x by y; always produces a ```float``` (or a complex if x or y is ```complex```)                                                                                                |
| x // y        | Divides x by y; truncates any fractional part so always produces an ```int``` result; see also the ```round()``` function                                                              |
| x % y         | Produces the modulus (remainder) of dividing x by y                                                                                                                                    |
| x ** y        | Raises x to the power of y; see also the ```pow()``` functions                                                                                                                         |
| -x            | Negates x; changes x’s sign if nonzero, does nothing if zero                                                                                                                           |
| +x            | Does nothing; is sometimes used to clarify code                                                                                                                                        |
| abs(x)        | Returns the absolute value of x                                                                                                                                                        |
| divmod(x, y)  | Returns the quotient and remainder of dividing x by y as a tuple of two ```ints```                                                                                                     |
| pow(x, y)     | Raises x to the power of y; the same as the ** operator                                                                                                                                |
| pow(x, y, z)  | A faster alternative to (x ** y) % z                                                                                                                                                   |
| round(x, n)   | Returns x rounded to n integral digits if n is a negative int or returns x rounded to n decimal places if n is a positive int; the returned value has the same type as x; see the text |

Integer Conversion Functions

| Syntax        | Description                                                                                                                                                                                    | 
| :------------ | :---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------:|
| bin(i)        | Returns the binary representation of int i as a string, e.g., ```bin(1980) == '0b11110111100'```                                                                                               |
| hex(i)        | Returns the hexadecimal representation of i as a string, e.g., ```hex(1980) == '0x7bc'```                                                                                                      |             
| int(x)        | Converts object x to an integer; raises ```ValueError``` on failure—or ```TypeError``` if x’s data type does not support integer conversion. If x is a floating-point number it is truncated.  |
| int(s, base)  | Converts ```str s``` to an integer; raises ```ValueError``` on failure. If the optional ```base``` argument is given it should be an integer between 2 and 36 inclusive.                       |
| oct(i)        | Returns the octal representation of i as a string, e.g., ```oct(1980) == '0o3674'```                                                                                                           |

Binary numbers are written with a leading 0b, octal numbers with a leading 0o, and hexadecimal numbers with a leading 0x. Uppercase letters can also be used.

```py
print(14600926) # decimal 14600926
print(0b110111101100101011011110) # binary 14600926
print(0o67545336) # octal 14600926
print(0xDECADE) # hexadecimal 14600926
```

Objects can be created by assigning literals to variables, for example, x = 17, or by calling the relevant data type as a function, for example, x = int(17). Some objects (e.g., those of type decimal.Decimal) can be created only by using the data type since they have no literal representation. When an object is created using its data type there are three possible use cases.

An object with a default value is created—for example, x = int() creates an integer of value 0. All the built-in types can be called with no arguments.

###### <a name="chapter2part2.2"></a>Chapter 2 - Part 2.2: Booleans

There are two built-in Boolean objects: True and False. Like all other Python data types (whether built-in, library, or custom), the bool data type can be called as a function. With no arguments it returns False, with a bool argument
it returns a copy of the argument, and with any other argument it attempts to convert the given object to a bool.

All the built-in and standard library data types can be converted to produce a Boolean value.

Python provides three logical operators: ```and```, ```or```, and ```not```.

```py
t = True
f = False
print(t and f) # False
print(t and True) # True
```

###### <a name="chapter2part2.3"></a>Chapter 2 - Part 2.3: Integer Bitwise Operators

Integer Bitwise Operators

| Syntax      | Description                                                                                           | 
| :---------- | :----------------------------------------------------------------------------------------------------:|
| i &#166; j  | Bitwise OR of int i and int j; negative numbers are assumed to b represented using 2’s complement     |
| i ^ j       | Bitwise XOR (exclusive or) of i and j                                                                 |             
| i & j       | Bitwise AND of i and j                                                                                |
| i << j      | Shifts i left by j bits; like i * (2 ** j) without overflow checking                                  |
| i >> j      | Shifts i right by j bits; like i // (2 ** j) without overflow checking                                |
| ~i          | Inverts i’s bits                                                                                      |

#### <a name="chapter2part3"></a>Chapter 2 - Part 3: Floating-Point Types

Python provides three kinds of floating-point values: the built-in ```float``` and ```complex``` types,and the ```decimal.Decimal``` type from the standard library.

All three are immutable.

```py
print(0.0) # 0.0
print(5.4) # 5.4
print(-2.5) # -2.5
print(8.9e-4) # 0.00089
```

###### <a name="chapter2part3.1"></a>Chapter 2 - Part 3.1: Floating-Point Numbers

The float data type can be called as a function with no arguments it returns 0.0,

```py
x = float()
print(x) # 0.0
```

With any other argument it attempts to convert the given object to a float

```py
x = float(1)
print(x) # 1.0
```

We can convert strings to floats

```py
x = float('1')
print(x) # 1.0
```

It is possible that NaN (“not a number”) or “infinity” may be produced by a calculation involving floats

Here is a simple function for comparing floats for equality to the limit of the machine’s accuracy:

```py
import sys

def equal_float(a, b):
    return abs(a - b) <= sys.float_info.epsilon

print(sys.float_info.epsilon) # 2.22044604925e-16

print(equal_float(1.0, 0.9999999999999999999999999999999999999999999999)) # True

print(equal_float(1.0, 0.99999999)) # False
```

```sys.float_info.epsilon``` is effectively the smallest difference that the machine can distinguish between two floating-point numbers.

Floating-point numbers can be converted to integers using the ```int()``` function which returns the whole part and throws away the fractional part, or using ```round()``` which accounts for the fractional part, or using ```math.floor()``` or ```math.ceil()``` which convert down to or up to the nearest integer.

```py
import math

y = 1.6

print(int(y)) # 1
print(round(y)) # 2.0
print(math.ceil(y)) # 2.0
```

For more Mathematical functions provided by Python, you can check her

[math — Mathematical functions](https://docs.python.org/3/library/math.html)

###### <a name="chapter2part3.2"></a>Chapter 2 - Part 3.2: Complex Numbers

The ```complex``` data type is an immutable type that holds a pair of ```floats```, one representing the real part and the other the imaginary part of a complex number.

```py
z = -89.5+2.125j

print(z.real) # -89.5
print(z.imag) #  2.125
```

Except for ```//, %, divmod()```, and the three-argument ```pow()```, all the numeric operators and functions in numeric operations table

The functions in the ```math module``` do not work with complex numbers. Users of complex numbers can import the ```cmath``` module

###### <a name="chapter2part3.3"></a>Chapter 2 - Part 3.3: Decimal Numbers

There are several different numeric data types in Python, including int, float, and complex numbers, but due to floating point numbers' machine-dependent nature, we need a more precise data type.

With the Python decimal module, decimal floating point arithmetic is carried out at high speed. In Python, numbers that contain decimal points are always treated as double-precision floating-point numbers. Decimal points have a smaller range than floats, but more precision. For monetary and financial calculations, it is appropriate. Also, it is more similar to how humans handle numbers.

Decimal modules have a precision that can be adjusted to any size necessary for a given problem, unlike hardware-based binary floating points.

```py
from decimal import Decimal
i = 8
j = 9
k = i / j
d = Decimal(i) / Decimal(j)
print (k, type(k)) # 0.8888888888888888 <class 'float'>
print (d, type(d)) # (Decimal('0.8888888888888888888888888889'), <class 'decimal.Decimal'>)
```
This output shows that float type objects have less precision than decimal type objects because their approximation method is much more aggressive. 

Unlike hardware based binary floating point, the decimal module has a user alterable precision (defaulting to 28 places) which can be as large as needed for a given problem:

```py
from decimal import *

getcontext().prec = 6
print(Decimal(1) / Decimal(7)) # 0.142857

getcontext().prec = 28
print(Decimal(1) / Decimal(7)) # 0.1428571428571428571428571429
```

#### <a name="chapter2part4"></a>Chapter 2 - Part 4: Strings

Strings are represented by the immutable ```str``` data type which holds a sequence of Unicode characters.

The str data type can be called as a function to create string objects

- with no arguments it returns an empty string
- with a nonstring argument it returns the string form of the argument
- with a string argument it returns a copy of the string

```py
x = str() 

y = str(1) 

z = str('abc') 

print(x) #
print(y) # 1
print(z) # abc
```

Strings can be delimited by double or single quotes, as long as the same kind are used at both ends, and since Python uses Unicode, strings are not limited to ASCII characters, as the penultimate string shows. An empty string is simply one with nothing between the delimiters.

```
"Infinitely Demanding"
'Simon Critchley'
'positively αβγ ÷©'
''
```

we can use a triple quoted string

```
text = """A triple quoted string like this can include 'quotes' and "quotes" without formality. We can also escape 
newlines \ so this particular string is actually only two lines long."""
```

If we want to use quotes inside a normal quoted string we can do so without formality if they are different from the delimiting quotes; otherwise, we must escape them:

```py
a = "Single 'quotes' are fine; \"doubles\" must be escaped."
b = 'Single \'quotes\' must be escaped; "doubles" are fine.'

print(a) # Single 'quotes' are fine; "doubles" must be escaped.
print(b) # Single 'quotes' must be escaped; "doubles" are fine.
```

Since ```.py``` files default to using the UTF-8 Unicode encoding, we can write any Unicode characters in our string literals without formality.

```py
print u'\u0420\u043e\u0441\u0441\u0438\u044f' # Россия
```

If we want to know the Unicode code point (the integer assigned to the character in the Unicode encoding) for a particular character in a string, we can use the built-in ```ord()```

```py
print(ord('t')) # 116

print(hex(ord('t'))) # 0x74
```

Similarly, we can convert any integer that represents a valid code point into the corresponding Unicode character using the built-in ```chr()``` function

```py
s = "anarchists are " + chr(8734) + chr(0x23B7)

print(s)
```

Python’s String Escapes

| Syntax      | Meaning                                                              | 
| :---------- | :-------------------------------------------------------------------:|
| \newline    | Escape (i.e., ignore) the newline                                    |
| \\          | Backslash (\)                                                        |             
| \'          | Single quote (’)                                                     |
| \"          | Double quote (")                                                     |
| \a          | ASCII bell (BEL)                                                     |
| \b          | ASCII backspace (BS)                                                 |
| \f          | ASCII formfeed (FF)                                                  |
| \n          | ASCII linefeed (LF)                                                  |
| \N{name}    | Unicode character with the given name                                |
| \ooo        | Character with the given octal value                                 |
| \r          | ASCII carriage return (CR)                                           |
| \t          | ASCII tab (TAB)                                                      |
| \uhhhh      | Unicode character with the given 16-bit hexadecimal value            |
| \Uhhhhhhhh  | Unicode character with the given 32-bit hexadecimal value            |
| \v          | ASCII vertical tab (VT)                                              |
| \xhh        | Character with the given 8-bit hexadecimal value                     |

###### <a name="chapter2part4.1"></a>Chapter 2 - Part 4.1: Comparing Strings

There is six ways to comparing strings in Python (```<, <=, ==, !=, >, and >=.```)

```py
print("Geek" == "Geek") # True
print("Geek" < "geek") # True
print("Geek" > "geek") # False
print("Geek" != "Geek") # False
```

- The ```==``` operator compares the values of both operands and checks for value equality. The same is the case for ```!=```

```py
print("Geek" == "Geek") # True
print("Geek" != "Geek") # False
```

- Whereas ```is``` operator checks whether both the operands refer to the same object or not. In this case, the id(). The same for ```is not```

```py
str1 = "Geek"
str2 = "Geek"
str3 = str1
 
print("ID of str1 =", hex(id(str1))) # ID of str1 = 0x7f6037051570
print("ID of str2 =", hex(id(str2))) # ID of str2 = 0x7f6037051570
print("ID of str3 =", hex(id(str3))) # ID of str3 = 0x7f6037051570
print(str1 is str1) # True
print(str1 is str2) # True
print(str1 is str3) # True
 
str1 += "s"
str4 = "Geeks"
 
print("\nID of changed str1 =", hex(id(str1))) # ID of changed str1 = 0x7f60356137d8
print("ID of str4 =", hex(id(str4))) # ID of str4 = 0x7f60356137a0
print(str1 is str4) # False
```

The operators <, <=, >, and >= returns True if the first string is lexicographically larger than the second string.

```py
str1="Hello"
str2="World"

print(str1>str2) # False
print(str1<str2) # True
print(str1>=str2) # False
print(str1<=str2) # True
```

###### <a name="chapter2part4.2"></a>Chapter 2 - Part 4.2: Slicing and Striding Strings

Index positions into a string begin at 0 and go up to the length of the string minus 1.

<br>

<div align="center"><img src="img/stringindex-w621-h272.png" width=621 height=272><br><sub>Python String Index - (<a href='https://www.geeksforgeeks.org/string-slicing-in-python/?ref=lbp'>Work by Geeks for Geeks</a>) </sub></div>

<br>

The slice operator has three syntaxes:

```
seq[start]
seq[start:end]
seq[start:end:step]
```

```py
# Python program to demonstrate
# string slicing
 
# String slicing
String = 'ASTRING'
 
# Using slice constructor
s1 = slice(3)
s2 = slice(1, 5, 2)
s3 = slice(-1, -12, -2)
 
print("String slicing") # String slicing
print(String[s1]) # AST
print(String[s2]) # SR
print(String[s3]) # GITA
```

```
arr[start:stop]         # items start through stop-1
arr[start:]             # items start through the rest of the array
arr[:stop]              # items from the beginning through stop-1
arr[:]                  # a copy of the whole array
arr[start:stop:step]    # start through not past stop, by step
```

```py
# Python program to demonstrate
# string slicing
 
# String slicing
String = 'GEEKSFORGEEKS'
 
# Using indexing sequence
print(String[:3]) # GEE
```

```py
s = "The waxwork man"

s = s[:12] + "wo" + s[12:]

print(s) # 'The waxwork woman'
```

###### <a name="chapter2part4.3"></a>Chapter 2 - Part 4.3: String Operators and Methods

Since strings are immutable sequences, all the functionality that can be used with immutable sequences can be used with strings.

As strings are sequences they are “sized” objects, and therefore we can call ```len()``` with a string as the argument.

```py
text = 'abcdf'

print(len(text)) # 5
```

We have seen that the + operator is overloaded to provide string concatenation.

```py


# Defining strings
var1 = "Hello "
var2 = "Geek"
 
# + Operator is used to combine strings
var3 = var1 + var2
print(var3) # Hello Geek
```

In cases where we want to concatenate lots of strings the str.join() method offers a better solution.

The method takes a sequence as an argument list or tuple of strings), and joins them together into a single string with the string the method was called on between each one.

```py
treatises = ["Arithmetica", "Conics", "Elements"]

print(" ".join(treatises)) # Arithmetica Conics Elements

print("".join(treatises)) # ArithmeticaConicsElements
```

The * operator provides string replication:

```py
s = "=" * 5

print(s) # =====
```

When applied to strings, the in membership operator returns True if its lefthand string argument is a substring of, or equal to, its right-hand string argument.

```py
s = 'tatio'

print('ta' in s) # True
```

In cases where we want to find the position of one string inside another, we can use 

- ```str.index()``` method; this returns the index position of the substring, or raises a ValueError exception on failure.
- ```str.find()``` method; this returns the index position of the substring, or -1 on failure.

We can check all most of the operation in the table above
 
| Escape                               | Description                                                                                                                                                                                                         | 
| :----------------------------------- | :------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------:|
|  s.capitalize()                      | Returns a copy of str s with the first letter capitalized; see also the str.title() method                                                                                                                          |
|  s.center(width, char)               | Returns a copy of s centered in a string of length width padded with spaces or optionally with char (a string of length 1); see str.ljust(), str.rjust(), and str.format()                                          |             
|  s.count(t, start, end)              | Returns the number of occurrences of str t in str s (or in the start:end slice of s)                                                                                                                                |
|  s.encode(encoding, err)             | Returns a bytes object that represents the string using the default encoding or using the specified encoding and handling errors according to the optional err argument                                             |
|  s.endswith(x, start, end)           | Returns True if s (or the start:end slice of s) ends with str x or with any of the strings in tuple x; otherwise, returns False. See also str.startswith().                                                         |
|  s.expandtabs(size)                  | Returns a copy of s with tabs replaced with spaces in multiples of 8 or of size if specified                                                                                                                        |
|  s.find(t, start, end)               | Returns the leftmost position of t in s (or in the start:end slice of s) or -1 if not found. Use str.rfind() to find the rightmost position. See also str.index().                                                  |
|  s.format(...)                       | Returns a copy of s formatted according to the given arguments.                                                                                                                                                     |
|  s.index(t, start, end)              | Returns the leftmost position of t in s (or in the start:end slice of s) or raises ValueError if not found. Use str.rindex() to search from the right. See str.find().                                              |
|  s.isalnum()                         | Returns True if s is nonempty and every character in s is alphanumeric                                                                                                                                              |
|  s.isalpha()                         | Returns True if s is nonempty and every character in s is alphabetic                                                                                                                                                |
|  s.isdecimal()                       | Returns True if s is nonempty and every character in s is a Unicode base 10 digit                                                                                                                                   |
|  s.isdigit()                         | Returns True if s is nonempty and every character in s is an ASCII digit                                                                                                                                            |
|  s.isidentifier()                    | Returns True if s is nonempty and is a valid identifier                                                                                                                                                             |
|  s.islower()                         | Returns True if s has at least one lowercaseable character and all its lowercaseable characters are lowercase; see also str.isupper()                                                                               |
|  s.isnumeric()                       | Returns True if s is nonempty and every character in s is a numeric Unicode character such as a digit or fraction                                                                                                   |
|  s.isprintable()                     | Returns True if s is empty or if every character in s is considered to be printable, including space, but not newline                                                                                               |
|  s.isspace()                         | Returns True if s is nonempty and every character in s is a whitespace character                                                                                                                                    |
|  s.istitle()                         | Returns True if s is a nonempty title-cased string; see also str.title()                                                                                                                                            |
|  s.isupper()                         | Returns True if str s has at least one uppercaseable character and all its uppercaseable characters are uppercase; see also str.islower()                                                                           |
|  s.join(seq)                         | Returns the concatenation of every item in the sequence seq, with str s (which may be empty) between each one                                                                                                       |
|  s.ljust(width, char)                | Returns a copy of s left-aligned in a string of length width padded with spaces or optionally with char (a string of length 1). Use str.rjust() to right-align and str.center() to center. See also str.format().   |
|  s.lower()                           | Returns a lowercased copy of s; see also str.upper()                                                                                                                                                                |
|  s.maketrans()                       | Companion of str.translate();                                                                                                                                                                                       |
|  s.partition(t)                      | Returns a tuple of three strings—the part of str s before the leftmost str t, t, and the part of s after t; or if t isn’t in s returns s and two empty strings.                                                     |
|  s.replace(t, u, n)                  | Returns a copy of s with every (or a maximum of n if given) occurrences of str t replaced with str u                                                                                                                |
|  s.split(t, n)                       | Returns a list of strings splitting at most n times on str t; if n isn’t given, splits as many times as possible; if t isn’t given, splits on whitespace.                                                           |
|  s.splitlines(f)                     | Returns the list of lines produced by splitting s on line terminators, stripping the terminators unless f is True                                                                                                   |
|  s.startswith(x, start, end)         | Returns True if s (or the start:end slice of s) starts with str x or with any of the strings in tuple x; otherwise, returns False. See also str.endswith().                                                         |
|  s.strip(chars)                      | Returns a copy of s with leading and trailing whitespace (or the characters in str chars) removed;str.lstrip() strips only at the start, and str.rstrip() strips only at the end                                    |
|  s.swapcase()                        | Returns a copy of s with uppercase characters lowercased and lowercase characters uppercased; see also str.lower() and str.upper()                                                                                  |
|  s.title()                           | Returns a copy of s where the first letter of each word is uppercased and all other letters are lowercased; see str.istitle()                                                                                       |
|  s.translate()                       | Companion of str.maketrans();                                                                                                                                                                                       |
|  s.upper()                           | Returns an uppercased copy of s; see also str.lower()                                                                                                                                                               |
|  s.zfill(w)                          | Returns a copy of s, which if shorter than w is padded with leading zeros to make it w characters long                                                                                                              |


###### <a name="chapter2part4.4"></a>Chapter 2 - Part 4.4: String Formatting with the str.format() Method

The ```str.format()``` method provides a very flexible and powerful way of creating strings.

```py
print("The novel '{0}' was published in {1}".format("Hard Times", 1854)) # The novel 'Hard Times' was published in 185

print("{{{0}}} {1} ;-}}".format("I'm in braces", "I'm not")) # {I'm in braces} I'm not ;-}

```

###### <a name="chapter2part4.5"></a>Chapter 2 - Part 4.5: Field Names

A field name can be either an integer corresponding to one of the str.format() method’s arguments, or the name of one of the method’s keyword arguments.

```py
print("{who} turned {age} this year".format(who="She", age=88)) # She turned 88 this year
print("The {who} was {0} last week".format(12, who="boy")) # The boy was 12 last week
```

Field names may refer to collection data types—for example, lists

```py
stock = ["paper", "envelopes", "notepads", "pens", "paper clips"]

print("We have {0[1]} and {0[2]} in stock".format(stock)) # We have envelopes and notepads in stock
```

With dictionaries

```py
d = dict(animal="elephant", weight=12000)

print("The {0[animal]} weighs {0[weight]}kg".format(d)) # The elephant weighs 12000kg
```

## <a name="chapter3"></a>Chapter 3: Collection Data Types

#### <a name="chapter3part1"></a>Chapter 3 - Part 1: Sequence Types

###### <a name="chapter3part1.1"></a>Chapter 3 - Part 1.1: Tuples

###### <a name="chapter3part1.2"></a>Chapter 3 - Part 1.2: Named Tuples

###### <a name="chapter3part1.3"></a>Chapter 3 - Part 1.3: Lists

###### <a name="chapter3part1.4"></a>Chapter 3 - Part 1.4: List Comprehensions

#### <a name="chapter3part2"></a>Chapter 3 - Part 2: Set Types

###### <a name="chapter3part2.1"></a>Chapter 3 - Part 2.1: Sets

###### <a name="chapter3part2.2"></a>Chapter 3 - Part 2.2: Set Comprehensions

###### <a name="chapter3part2.3"></a>Chapter 3 - Part 2.3: Frozen Sets

#### <a name="chapter3part3"></a>Chapter 3 - Part 3: Mapping Types

###### <a name="chapter3part3.1"></a>Chapter 3 - Part 3.1: Dictionaries

###### <a name="chapter3part3.2"></a>Chapter 3 - Part 3.2: Dictionary Comprehensions

###### <a name="chapter3part3.3"></a>Chapter 3 - Part 3.3: Default Dictionaries

###### <a name="chapter3part3.4"></a>Chapter 3 - Part 3.4: Ordered Dictionaries

#### <a name="chapter3part4"></a>Chapter 3 - Part 4: Iterating and Copying Collections

###### <a name="chapter3part4.1"></a>Chapter 3 - Part 4.1: Iterators and Iterable Operations and Functions

###### <a name="chapter3part4.2"></a>Chapter 3 - Part 4.2: Copying Collections

## <a name="chapter4"></a>Chapter 4: Control Structures and Functions

#### <a name="chapter4part1"></a>Chapter 4 - Part 1: Control Structures

###### <a name="chapter4part1.1"></a>Chapter 4 - Part 1.1: Conditional Branching

###### <a name="chapter4part1.2"></a>Chapter 4 - Part 1.2: Looping

###### <a name="chapter4part1.3"></a>Chapter 4 - Part 1.3: While Loops

###### <a name="chapter4part1.4"></a>Chapter 4 - Part 1.4: For Loops

#### <a name="chapter4part2"></a>Chapter 4 - Part 2: Exception Handling

###### <a name="chapter4part2.1"></a>Chapter 4 - Part 2.1: Catching and Raising Exceptions

###### <a name="chapter4part2.2"></a>Chapter 4 - Part 2.2: Raising Exceptions

###### <a name="chapter4part2.3"></a>Chapter 4 - Part 2.3: Custom Exceptions

#### <a name="chapter4part3"></a>Chapter 4 - Part 3: Custom Functions

###### <a name="chapter4part3.1"></a>Chapter 4 - Part 3.1: Names and Docstrings

###### <a name="chapter4part3.2"></a>Chapter 4 - Part 3.2: Argument and Parameter Unpacking

###### <a name="chapter4part3.3"></a>Chapter 4 - Part 3.3: Accessing Variables in the Global Scope

###### <a name="chapter4part3.4"></a>Chapter 4 - Part 3.4: Lambda Functions

###### <a name="chapter4part3.5"></a>Chapter 4 - Part 3.5: Assertions

## <a name="chapter5"></a>Chapter 5: Modules

#### <a name="chapter5part1"></a>Chapter 5 - Part 1: Modules and Packages

###### <a name="chapter5part1.1"></a>Chapter 5 - Part 1.1: Packages

###### <a name="chapter5part1.2"></a>Chapter 5 - Part 1.2: Custom Modules

###### <a name="chapter5part1.3"></a>Chapter 5 - Part 1.3: The TextUtil Module

###### <a name="chapter5part1.4"></a>Chapter 5 - Part 1.4: The CharGrid Module

#### <a name="chapter5part2"></a>Chapter 5 - Part 2: Overview of Python’s Standard Library

###### <a name="chapter5part2.1"></a>Chapter 5 - Part 2.1: String Handling

###### <a name="chapter5part2.2"></a>Chapter 5 - Part 2.2: Command-Line Programming

###### <a name="chapter5part2.3"></a>Chapter 5 - Part 2.3: Mathematics and Numbers

###### <a name="chapter5part2.4"></a>Chapter 5 - Part 2.4: Times and Dates

###### <a name="chapter5part2.5"></a>Chapter 5 - Part 2.5: Algorithms and Collection Data Types

###### <a name="chapter5part2.6"></a>Chapter 5 - Part 2.6: File Formats, Encodings, and Data Persistence

###### <a name="chapter5part2.7"></a>Chapter 5 - Part 2.7: File, Directory, and Process Handling

###### <a name="chapter5part2.8"></a>Chapter 5 - Part 2.8: Networking and Internet Programming

###### <a name="chapter5part2.9"></a>Chapter 5 - Part 2.9: XML

###### <a name="chapter5part2.10"></a>Chapter 5 - Part 2.10: Other Modules

## <a name="chapter6"></a>Chapter 6: Object-Oriented Programming

#### <a name="chapter6part1"></a>Chapter 6 - Part 1: The Object-Oriented Approach

###### <a name="chapter6part1.1"></a>Chapter 6 - Part 1.1: Object-Oriented Concepts and Terminology

#### <a name="chapter6part2"></a>Chapter 6 - Part 2: Custom Classes

###### <a name="chapter6part2.1"></a>Chapter 6 - Part 2.1: Attributes and Methods

###### <a name="chapter6part2.2"></a>Chapter 6 - Part 2.2: Inheritance and Polymorphism

###### <a name="chapter6part2.3"></a>Chapter 6 - Part 2.3: Using Properties to Control Attribute Access

###### <a name="chapter6part2.4"></a>Chapter 6 - Part 2.4: Creating Complete Fully Integrated Data Types

###### <a name="chapter6part2.5"></a>Chapter 6 - Part 2.5: Creating Data Types from Scratch

###### <a name="chapter6part2.6"></a>Chapter 6 - Part 2.6: Creating Data Types from Other Data Types

#### <a name="chapter6part3"></a>Chapter 6 - Part 3: Custom Collection Classes

###### <a name="chapter6part3.1"></a>Chapter 6 - Part 3.1: Creating Classes That Aggregate Collections

###### <a name="chapter6part3.2"></a>Chapter 6 - Part 3.2: Creating Collection Classes Using Aggregation

###### <a name="chapter6part3.3"></a>Chapter 6 - Part 3.3: Creating Collection Classes Using Inheritance

## <a name="chapter7"></a>Chapter 7: File Handling

#### <a name="chapter7part1"></a>Chapter 7 - Part 1: Writing and Reading Binary Data

###### <a name="chapter7part1.1"></a>Chapter 7 - Part 1.1: Pickles with Optional Compression

###### <a name="chapter7part1.2"></a>Chapter 7 - Part 1.2: Raw Binary Data with Optional Compression

#### <a name="chapter7part2"></a>Chapter 7 - Part 2: Writing and Parsing Text Files

###### <a name="chapter7part2.1"></a>Chapter 7 - Part 2.1: Writing Text

###### <a name="chapter7part2.2"></a>Chapter 7 - Part 2.2: Parsing Text

###### <a name="chapter7part2.3"></a>Chapter 7 - Part 2.3: Parsing Text Using Regular Expressions

#### <a name="chapter7part3"></a>Chapter 7 - Part 3: Writing and Parsing XML Files

###### <a name="chapter7part3.1"></a>Chapter 7 - Part 3.1: Element Trees

###### <a name="chapter7part3.2"></a>Chapter 7 - Part 3.2: DOM (Document Object Model

###### <a name="chapter7part3.3"></a>Chapter 7 - Part 3.3: Manually Writing XML

###### <a name="chapter7part3.4"></a>Chapter 7 - Part 3.4: Parsing XML with SAX (Simple API for XML)

#### <a name="chapter7part4"></a>Chapter 7 - Part 4: Random Access Binary Files

###### <a name="chapter7part4.1"></a>Chapter 7 - Part 4.1: A Generic BinaryRecordFile Class

## <a name="chapter8"></a>Chapter 8: Useful Python Code Snippet

#### <a name="chapter8part1"></a>Chapter 8 - Part 1: Create a Log file

```py
import logging
import os
from datetime import datetime

# CONST

LOG_PREFIX_NAME_CONST = 'MYLOGGER_'
LOG_FILE_NAME_CONST = 'myloggername_log_file'
LOG_DIR_NAME_CONST = 'myloggerfolder-logs'
LOG_DEFAULT_VALUE = logging.INFO

logger = None  # Initialize the logger variable

def main():
    log_prefix_name = LOG_PREFIX_NAME_CONST
    log_file_name = LOG_FILE_NAME_CONST
    log_dir_name = LOG_DIR_NAME_CONST

    global logger
    logger = setup_logger(log_prefix_name, level=LOG_DEFAULT_VALUE, log_file_prefix=log_file_name, log_dir=log_dir_name)

    logger_execute()

def setup_logger(name, level, log_file_prefix, log_dir):
    global logger

    # Ensure the log directory exists
    if not os.path.exists(log_dir):
        os.makedirs(log_dir)

    # Create a logger object
    logger = logging.getLogger(name)
    logger.setLevel(level)

    # Get the current date to include in the log file name
    current_date = datetime.now().strftime('%Y-%m-%d')
    log_file = os.path.join(log_dir, '{log_file_prefix}_{current_date}.log'.format(log_file_prefix=log_file_prefix,
                                                                                   current_date=current_date))

    # Create a file handler
    file_handler = logging.FileHandler(log_file)
    file_handler.setLevel(level)

    # Create a log format
    formatter = logging.Formatter('%(asctime)s - %(name)s - %(levelname)s - %(message)s')
    file_handler.setFormatter(formatter)

    # Add the file handler to the logger
    if not logger.handlers:
        logger.addHandler(file_handler)

    return logger

def logger_execute():
    global logger
    logger.info('------------ Executing MYLOGGER INFO ------------')
    logger.error('------------ Executing MYLOGGER ERROR ------------')

if __name__ == "__main__":
    main()

```

#### <a name="chapter8part2"></a>Chapter 8 - Part 2: List all files of a directory based in a extension

```py
import os


def main():
    directory_files = list_files_in_directory(os.getcwd(), 'json')
    for file in directory_files:
        print(file)


def list_files_in_directory(directory, file_extension):
    directory_files = []
    if os.path.isdir(directory):
        try:
            items = os.listdir(directory)
            for item in items:
                item_path = os.path.join(directory, item)
                if os.path.isfile(item_path) and item_path.endswith('.%s' % file_extension):
                    directory_files.append(item)
            return directory_files
        except OSError as error:
            print("Error accessing directory: %s" % error)
    else:
        print("%s is not a valid directory." % directory)
    return directory_files


if __name__ == "__main__":
    main()

```

#### <a name="chapter8part3"></a>Chapter 8 - Part 3: List all files of a directory based in a regex

```py
import os
import re


def main():
    directory_files = list_files_in_directory(os.getcwd(), r'.*\.csv$')
    for file in directory_files:
        print(file)


def list_files_in_directory(directory, file_regex):
    directory_files = []
    if os.path.isdir(directory):
        try:
            items = os.listdir(directory)
            regex = re.compile(file_regex)
            for item in items:
                item_path = os.path.join(directory, item)
                if os.path.isfile(item_path) and regex.match(item):
                    directory_files.append(item)
            return directory_files
        except OSError as error:
            print("Error accessing directory: %s" % error)
    else:
        print("%s is not a valid directory." % directory)
    return directory_files


if __name__ == "__main__":
    main()

```

#### <a name="chapter8part4"></a>Chapter 8 - Part 4: Move file to a directory

```py
import os
import shutil


def main():
    move_file_to_dir('test.csv', 'abc', False)


def move_file_to_dir(file, dir_name, overwrite=False):
    # Ensure the directory exists
    if not os.path.exists(dir_name):
        os.makedirs(dir_name)

    src_file_path = None
    dst_folder = None
    dst_file_path = None
    try:
        src_file_path = os.path.abspath(file)
        dst_folder = os.path.abspath(dir_name)
        dst_file_path = os.path.join(dst_folder, os.path.basename(src_file_path))

        # Check if the destination file exists
        if os.path.exists(dst_file_path):
            if overwrite:
                print('File {} already exist in the destination folder {}: '
                      'Overwrite the file'.format(src_file_path, dst_folder))
                os.remove(dst_file_path)
            else:
                raise Exception('File already exists at destination: {}'.format(dst_file_path))

        shutil.move(src_file_path, dst_folder)

    except Exception as error:
        print('Error in move files from {} to {}: {}'.format(src_file_path, dst_folder, error))

    return dst_file_path


if __name__ == "__main__":
    main()

```

#### <a name="chapter8part5"></a>Chapter 8 - Part 5: Read a Config Json File

config_file.json

```json
{
	"configOne": "example_1",
	"configTwo": "example_2",
	"dataConfig": {
		"product": {
			"columnsMapper": {
				"columnOne": "column1",
				"columnTwo": "column2",
				"columnThree": "column3",
				"columnFour": "column4"
			}
		},
		"item": {
			"columnsMapper": {
				"columnOne": "column1",
				"columnTwo": "column2"
			}
		}
	}
}
```

```py
import json
import os
from collections import OrderedDict


def main():
    config_file = load_json_config('config_file.json')

    config_one = config_file['configOne']
    config_two = config_file['configTwo']

    print(config_one)
    print(config_two)

    data_config = config_file['dataConfig']

    # Read each object of dataConfig node
    for key, value in data_config.items():
        columns_mapper = value['columnsMapper']

        print(key)
        print(columns_mapper)


def load_json_config(json_file):
    try:
        json_file_path = os.path.abspath(json_file)
        with open(json_file_path, 'r') as file:
            return json.load(file, object_pairs_hook=OrderedDict)

    except Exception as error:
        print(error)


if __name__ == "__main__":
    main()

```

#### <a name="chapter8part6"></a>Chapter 8 - Part 6: Read and Parse a CSV file with Pandas based in a Config Json File

config_file.json

```json

{
	"configOne": "example_1",
	"configTwo": "example_2",
	"dataConfig": {
		"product": {
			"fileName": "product_file",
			"columnsMapper": {
				"columnOne": "column1",
				"columnTwo": "column2",
				"columnThree": "column3",
				"columnFour": "column4"
			}
		},
		"item": {
			"fileName": "item_file",
			"columnsMapper": {
				"columnOne": "column1",
				"columnTwo": "column2"
			}
		}
	}
}

```

test.csv

```csv
"column1","column2","column3","column4"
"1","","3","4"
"5","","7","8"
"a","","c","d"
"e","","g","h"
"i","","l","m"
"n","","p","q"
```

```py
import json
import os
from collections import OrderedDict

import pandas as pd


def main():
    config_file = load_json_config('config_file.json')

    data_config = config_file['dataConfig']

    # Read each object of dataConfig node
    for key, value in data_config.items():
        final_file_name = value['fileName']
        columns_mapper = value['columnsMapper']

        create_csv_with_clean_data('test.csv', columns_mapper, final_file_name, key)


def load_json_config(json_file):
    try:
        json_file_path = os.path.abspath(json_file)
        with open(json_file_path, 'r') as file:
            return json.load(file, object_pairs_hook=OrderedDict)

    except Exception as error:
        print(error)


def create_csv_with_clean_data(file_path, columns_mapper, final_file_name, key):
    try:
        df = pd.read_csv(file_path)

        new_df = map_df_columns_to_file_config(df, columns_mapper)

        if key == 'item':
            new_df['columnTwo'] = new_df['columnTwo'].apply(fill_empty_field_with_value)

        new_df.to_csv(final_file_name, sep='|', index=False)

    except Exception as error:

        print(error)

        raise


def fill_empty_field_with_value(column_two_value):
    if pd.isna(column_two_value):
        column_two_value = 'someValue'
    return column_two_value


def map_df_columns_to_file_config(df, columns_mapper):
    new_columns = OrderedDict()

    for output_col, input_col in columns_mapper.items():
        if input_col:
            # Check if input_col exist in the df
            if input_col in df.columns:
                new_columns[output_col] = df[input_col]
            # If not, is a fixed value
            else:
                new_columns[output_col] = input_col
        else:
            new_columns[output_col] = ""

    return pd.DataFrame(new_columns)


if __name__ == "__main__":
    main()
```
